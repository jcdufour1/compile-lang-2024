/* autogenerated */
#ifndef SYMBOL_TABLE_H
#define SYMBOL_TABLE_H

#include "str_view.h"
#include "string.h"
#include "env.h"
#include "symbol_table_struct.h"
#include "do_passes.h"
#include <uast_forward_decl.h>
#include <tast_forward_decl.h>
#include <llvm_forward_decl.h>

void usymbol_extend_table_internal(String* buf, const Usymbol_table sym_table, int recursion_depth);
void usymbol_log_table_internal(int log_level, const Usymbol_table sym_table, int recursion_depth, const char* file_path, int line);

#define usymbol_log_table(log_level, sym_table) \
    do { \
        usymbol_log_table_internal(log_level, sym_table, 0, __FILE__, __LINE__); \
    } while(0)

// returns false if symbol is already added to the table
bool usym_tbl_add_internal(Usymbol_table_tast* sym_tbl_tasts, size_t capacity, Uast_def* tast_of_symbol);

bool usym_tbl_lookup_internal(Usymbol_table_tast** result, const Usymbol_table* sym_table, Str_view key);

bool usym_tbl_lookup(Env* env, Uast_def** result, const Usymbol_table* sym_table, Name key);

// returns false if symbol has already been added to the table
bool usym_tbl_add(Env* env, Usymbol_table* sym_table, Uast_def* tast_of_symbol);

void usym_tbl_update(Env* env, Usymbol_table* sym_table, Uast_def* tast_of_symbol);

bool usymbol_lookup(Uast_def** result, Env* env, Name key);

bool usymbol_add(Env* env, Uast_def* tast_of_symbol);

void usymbol_update(Env* env, Uast_def* tast_of_symbol);

void symbol_extend_table_internal(String* buf, const Symbol_table sym_table, int recursion_depth);
void symbol_log_table_internal(int log_level, const Symbol_table sym_table, int recursion_depth, const char* file_path, int line);

#define symbol_log_table(log_level, sym_table) \
    do { \
        symbol_log_table_internal(log_level, sym_table, 0, __FILE__, __LINE__); \
    } while(0)

// returns false if symbol is already added to the table
bool sym_tbl_add_internal(Symbol_table_tast* sym_tbl_tasts, size_t capacity, Tast_def* tast_of_symbol);

bool sym_tbl_lookup_internal(Symbol_table_tast** result, const Symbol_table* sym_table, Str_view key);

bool sym_tbl_lookup(Env* env, Tast_def** result, const Symbol_table* sym_table, Name key);

// returns false if symbol has already been added to the table
bool sym_tbl_add(Env* env, Symbol_table* sym_table, Tast_def* tast_of_symbol);

void sym_tbl_update(Env* env, Symbol_table* sym_table, Tast_def* tast_of_symbol);

bool symbol_lookup(Tast_def** result, Env* env, Name key);

bool symbol_add(Env* env, Tast_def* tast_of_symbol);

void symbol_update(Env* env, Tast_def* tast_of_symbol);

void alloca_extend_table_internal(String* buf, const Alloca_table sym_table, int recursion_depth);
void alloca_log_table_internal(int log_level, const Alloca_table sym_table, int recursion_depth, const char* file_path, int line);

#define alloca_log_table(log_level, sym_table) \
    do { \
        alloca_log_table_internal(log_level, sym_table, 0, __FILE__, __LINE__); \
    } while(0)

// returns false if symbol is already added to the table
bool all_tbl_add_internal(Alloca_table_tast* sym_tbl_tasts, size_t capacity, Llvm* tast_of_symbol);

bool all_tbl_lookup_internal(Alloca_table_tast** result, const Alloca_table* sym_table, Str_view key);

bool all_tbl_lookup(Llvm** result, const Alloca_table* sym_table, Str_view key);

// returns false if symbol has already been added to the table
bool all_tbl_add(Env* env, Alloca_table* sym_table, Llvm* tast_of_symbol);

void all_tbl_update(Env* env, Alloca_table* sym_table, Llvm* tast_of_symbol);

bool alloca_lookup(Llvm** result, Env* env, Name key);

bool alloca_add(Env* env, Llvm* tast_of_symbol);

void alloca_update(Env* env, Llvm* tast_of_symbol);

// these tasts will be actually added to a symbol table when `symbol_do_add_defered` is called
static inline void alloca_add_defer(Env* env, Llvm* tast_of_alloca) {
    assert(tast_of_alloca);
    vec_append(&a_main, &env->defered_allocas_to_add, tast_of_alloca);
}

bool alloca_do_add_defered(Llvm** redefined_sym, Env* env);

static inline void alloca_ignore_defered(Env* env) {
    vec_reset(&env->defered_allocas_to_add);
}

// these tasts will be actually added to a symbol table when `symbol_do_add_defered` is called
static inline void symbol_add_defer(Env* env, Tast_def* tast_of_symbol) {
    assert(tast_of_symbol);
    vec_append(&a_main, &env->defered_symbols_to_add, tast_of_symbol);
}

bool symbol_do_add_defered(Tast_def** redefined_sym, Env* env);

static inline void symbol_ignore_defered(Env* env) {
    vec_reset(&env->defered_symbols_to_add);
}

// these tasts will be actually added to a symbol table when `symbol_do_add_defered` is called
static inline void usymbol_add_defer(Env* env, Uast_def* uast_of_symbol) {
    assert(uast_of_symbol);
    vec_append(&a_main, &env->udefered_symbols_to_add, uast_of_symbol);
}

bool usymbol_do_add_defered(Uast_def** redefined_sym, Env* env);

static inline void usymbol_ignore_defered(Env* env) {
    vec_reset(&env->udefered_symbols_to_add);
}

Symbol_table* symbol_get_block(Env* env);

void log_symbol_table_if_block(Env* env, const char* file_path, int line);

#define SYM_TBL_STATUS_FMT "%s"

const char* sym_tbl_status_print(SYM_TBL_STATUS status);

bool file_path_to_text_tbl_lookup(Str_view** result, const File_path_to_text* sym_table, Str_view key);

// returns false if file_path_to_text has already been added to the table
bool file_path_to_text_tbl_add(File_path_to_text* sym_table, Str_view* file_text, Str_view key);

#endif // SYMBOL_TABLE_H

