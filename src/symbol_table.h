/* autogenerated */
#ifndef SYMBOL_TABLE_H
#define SYMBOL_TABLE_H

#include "str_view.h"
#include <newstring.h>
#include "symbol_table_struct.h"
#include <do_passes.h>
#include <uast_forward_decl.h>
#include <tast_forward_decl.h>
#include <llvm_forward_decl.h>
#include <env.h>

void usymbol_extend_table_internal(String* buf, const Usymbol_table sym_table, int recursion_depth);
void usymbol_log_table_internal(int log_level, const Usymbol_table sym_table, int recursion_depth, const char* file_path, int line);

#define usymbol_log_table(log_level, sym_table) \
    do { \
        usymbol_log_table_internal(log_level, sym_table, 0, __FILE__, __LINE__); \
    } while(0)

// returns false if symbol is already added to the table
bool usym_tbl_add_internal(Usymbol_table_tast* sym_tbl_tasts, size_t capacity, Uast_def* tast_of_symbol);

bool usym_tbl_lookup_internal(Usymbol_table_tast** result, const Usymbol_table* sym_table, Str_view key);

bool usym_tbl_lookup(Uast_def** result, Name key);

// returns false if symbol has already been added to the table
bool usym_tbl_add(Uast_def* tast_of_symbol);

void usym_tbl_update(Uast_def* tast_of_symbol);

bool usymbol_lookup(Uast_def** result, Name key);

bool usymbol_add(Uast_def* tast_of_symbol);

void usymbol_update(Uast_def* tast_of_symbol);

void symbol_extend_table_internal(String* buf, const Symbol_table sym_table, int recursion_depth);
void symbol_log_table_internal(int log_level, const Symbol_table sym_table, int recursion_depth, const char* file_path, int line);

#define symbol_log_table(log_level, sym_table) \
    do { \
        symbol_log_table_internal(log_level, sym_table, 0, __FILE__, __LINE__); \
    } while(0)

// returns false if symbol is already added to the table
bool sym_tbl_add_internal(Symbol_table_tast* sym_tbl_tasts, size_t capacity, Tast_def* tast_of_symbol);

bool sym_tbl_lookup_internal(Symbol_table_tast** result, const Symbol_table* sym_table, Str_view key);

bool sym_tbl_lookup(Tast_def** result, Name key);

// returns false if symbol has already been added to the table
bool sym_tbl_add(Tast_def* tast_of_symbol);

void sym_tbl_update(Scope_id scope_id, Tast_def* tast_of_symbol);

bool symbol_lookup(Tast_def** result, Name key);

bool symbol_add(Tast_def* tast_of_symbol);

void symbol_update(Tast_def* tast_of_symbol);

void alloca_extend_table_internal(String* buf, const Alloca_table sym_table, int recursion_depth);
void alloca_log_table_internal(int log_level, const Alloca_table sym_table, int recursion_depth, const char* file_path, int line);

#define alloca_log_table(log_level, sym_table) \
    do { \
        alloca_log_table_internal(log_level, sym_table, 0, __FILE__, __LINE__); \
    } while(0)

// returns false if symbol is already added to the table
bool all_tbl_add_internal(Alloca_table_tast* sym_tbl_tasts, size_t capacity, Llvm* tast_of_symbol);

bool all_tbl_lookup_internal(Alloca_table_tast** result, const Alloca_table* sym_table, Str_view key);

bool all_tbl_lookup(Llvm** result, Name key);

// returns false if symbol has already been added to the table
bool all_tbl_add(Llvm* tast_of_symbol);

void all_tbl_update(Llvm* tast_of_symbol);

bool alloca_lookup(Llvm** result, Name key);

bool alloca_add(Llvm* tast_of_symbol);

void alloca_update(Llvm* tast_of_symbol);

Symbol_table* symbol_get_block(void);

void log_symbol_table_if_block(const char* file_path, int line);

#define SYM_TBL_STATUS_FMT "%s"

const char* sym_tbl_status_print(SYM_TBL_STATUS status);

bool file_path_to_text_tbl_lookup(Str_view** result, const File_path_to_text* sym_table, Str_view key);

// returns false if file_path_to_text has already been added to the table
bool file_path_to_text_tbl_add(File_path_to_text* sym_table, Str_view* file_text, Str_view key);

// returns parent of key
Scope_id scope_tbl_lookup(Scope_id key);

bool scope_tbl_add(Scope_id key, Scope_id next);

void scope_tbl_update(Scope_id key, Scope_id parent);

Scope_id symbol_collection_new(Scope_id parent);

#define SCOPE_BUILTIN 0
#define SCOPE_TOP_LEVEL 1
#define SCOPE_NOT SIZE_MAX

#endif // SYMBOL_TABLE_H

