#ifndef UTIL_H
#define UTIL_H

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <strv_struct.h>
#include <diag_type.h>

typedef enum {
    LOG_NEVER = 0,
    LOG_TRACE,
    LOG_DEBUG,
    LOG_VERBOSE,
    LOG_INFO,
    LOG_NOTE,
    LOG_WARNING,
    LOG_ERROR,
    LOG_FATAL,
} LOG_LEVEL;

#ifndef MIN_LOG_LEVEL
#define MIN_LOG_LEVEL LOG_TRACE
#endif // CURR_LOG_LEVEL

typedef enum {
    EXIT_CODE_SUCCESS = 0,
    EXIT_CODE_FAIL,
    EXIT_CODE_EXPECTED_FAIL,
} EXIT_CODE;

struct Env_;
typedef struct Env_ Env;

struct Uast_def_;
typedef struct Uast_def_ Uast_def;

// TODO: try to eventually store only uint64_t directly in Pos to improve compile times?
typedef struct Pos_ {
    Strv file_path;
    uint32_t line;
    uint32_t column;

    // NULL means that that is nothing that this expression was expanded from
    struct Pos_* expanded_from;
} Pos;

#define POS_BUILTIN ((Pos) {.file_path = {.count = SIZE_MAX}})

// log* functions and macros print messages that are intended for debugging
static inline void log_internal(LOG_LEVEL log_level, const char* file, int line, int indent, const char* format, ...) 
__attribute__((format (printf, 5, 6)));

#include <log_internal.h>

#define log_indent_file(...) \
    do { \
        log_internal(__VA_ARGS__); \
    } while(0) 

#define log_indent(log_level, indent, ...) \
    log_internal(log_level, __FILE__, __LINE__, indent, __VA_ARGS__)

#define log_file_new(log_level, file, line, ...) \
    log_internal(log_level, file, line, 0, __VA_ARGS__)

#define log(log_level, ...) \
    log_internal(log_level, __FILE__, __LINE__, 0, __VA_ARGS__);

#define todo() \
    do { \
        log(LOG_FATAL, "not implemented\n"); \
        abort(); \
    } while (0);

#define unreachable(...) \
    do { \
        log(LOG_FATAL, "unreachable:"); \
        fprintf(stderr, __VA_ARGS__); \
        fprintf(stderr, "\n"); \
        abort(); \
    } while (0)

// TODO
//static inline Strv bool_print(bool condition) {
//    if (condition) {
//        return sv("true");
//    }
//    return sv("false");
//}

#define array_count(array) (sizeof(array)/sizeof((array)[0]))

#define array_at(array, index) \
    (unwrap((index) < array_count(array) && "out of bounds"), (array)[index])

#define array_at_ref(array, index) \
    (unwrap((index) < array_count(array) && "out of bounds"), &(array)[index])

#define min(a, b) ((a) < (b) ? (a) : (b))

#define max(a, b) ((a) > (b) ? (a) : (b))

#define INLINE static inline __attribute__((always_inline))

#define get_next_multiple(num, divisor) (num + (divisor - num%divisor)%divisor)

static inline void unwrap_internal(bool cond, const char* cond_text, const char* file, int line) {
    if (!(cond)) {
        log_internal(LOG_FATAL, file, line, 0, "condition \"%s\" failed\n", cond_text);
        abort();
    }
}

#define unwrap(cond) unwrap_internal(cond, #cond, __FILE__, __LINE__)

extern Env env;
extern char PATH_SEPARATOR;

// TODO: move this?
typedef size_t Scope_id;

#ifndef INDENT_WIDTH
#define INDENT_WIDTH 2
#endif // INDENT_WIDTH

// TODO: consider if this is the ideal place
// TODO: make SCOPE_BUILTIN and SCOPE_TOP_LEVEL the same?
#define SCOPE_BUILTIN 0
#define SCOPE_TOP_LEVEL 1
#define SCOPE_NOT SIZE_MAX

#define MOD_PATH_STD (sv("std/"))
// MOD_PATH_BUILTIN is used mostly for symbols generated by the compiler itself
#define MOD_PATH_BUILTIN (sv("builtin"))
// MOD_PATH_RUNTIME is used for standard library functions that are used by the compiler itself
#define MOD_PATH_RUNTIME (sv("std/runtime")) /* TODO: try to avoid hardcoding path separator? */
#define MOD_PATH_PRELUDE (sv("std/prelude"))
#define MOD_PATH_OF_MOD_PATHS (sv("std/does_not_exist/mod_paths"))
#define MOD_PATH_ARRAYS (sv("std/does_not_exist/arrays"))
#define MOD_PATH_EXTERN_C ((Strv) {0})

#define MOD_ALIAS_BUILTIN (name_new(MOD_PATH_BUILTIN, sv("mod_aliases"), (Ulang_type_vec) {0}, SCOPE_BUILTIN))
#define MOD_ALIAS_TOP_LEVEL (name_new(MOD_PATH_BUILTIN, sv("mod_aliases_top_level"), (Ulang_type_vec) {0}, SCOPE_BUILTIN))
#define MOD_ALIAS_PRELUDE (name_new(MOD_PATH_BUILTIN, sv("mod_aliases_prelude"), (Ulang_type_vec) {0}, SCOPE_BUILTIN))


#define EXTERN_C_OWN_PREFIX "own"

#define FMT "%.*s"

#endif // UTIL_H
