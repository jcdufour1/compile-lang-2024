#ifndef UTIL_H
#define UTIL_H

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <strv_struct.h>
#include <diag_type.h>
#include <assert.h>

typedef enum {
    LOG_NEVER = 0,
    LOG_TRACE,
    LOG_DEBUG,
    LOG_VERBOSE,
    LOG_INFO,
    LOG_NOTE,
    LOG_WARNING,
    LOG_ERROR,
    LOG_FATAL,

    // for static asserts
    LOG_COUNT,
} LOG_LEVEL;

// TODO: make this more cross platform
#define breakpoint() __asm__("int3")

#define QSORT_LESS_THAN (-1)
#define QSORT_EQUAL 0
#define QSORT_MORE_THAN 1

#ifndef MIN_LOG_LEVEL
#define MIN_LOG_LEVEL LOG_TRACE
#endif // CURR_LOG_LEVEL

typedef enum {
    EXIT_CODE_SUCCESS = 0,
    EXIT_CODE_FAIL,
} EXIT_CODE;

typedef uint32_t Indent;

struct Env_;
typedef struct Env_ Env;

struct Uast_def_;
typedef struct Uast_def_ Uast_def;

// TODO: try to eventually store only uint64_t directly in Pos to improve memory usage?
typedef struct Pos_ {
    Strv file_path;
    uint32_t line;
    uint32_t column;

    // NULL means that that is nothing that this expression was expanded from
    struct Pos_* expanded_from;
} Pos;

#define POS_BUILTIN ((Pos) {.file_path = MOD_PATH_BUILTIN})

// log* functions and macros print messages that are intended for debugging
static inline void log_internal(LOG_LEVEL log_level, const char* file, int line, Indent indent, const char* format, ...) 
__attribute__((format (printf, 5, 6)));

#include <log_internal.h>

#define log_indent_file(...) \
    do { \
        log_internal(__VA_ARGS__); \
    } while(0) 

#define log_indent(log_level, indent, ...) \
    log_internal(log_level, __FILE__, __LINE__, indent, __VA_ARGS__)

#define log_file_new(log_level, file, line, ...) \
    if (log_level >= MIN_LOG_LEVEL && log_level >= params_log_level) { \
        log_internal(log_level, file, line, 0, __VA_ARGS__); \
    }

#define log(log_level, ...) \
    if (log_level >= MIN_LOG_LEVEL && log_level >= params_log_level) { \
        log_internal(log_level, __FILE__, __LINE__, 0, __VA_ARGS__); \
    }

#define todo() \
    do { \
        log(LOG_FATAL, "not implemented\n"); \
        abort(); \
    } while (0);

#define unreachable(...) \
    do { \
        log(LOG_FATAL, "unreachable:"); \
        fprintf(stderr, __VA_ARGS__); \
        fprintf(stderr, "\n"); \
        abort(); \
    } while (0)

#define fallthrough \
    do { \
    } while(0); \
    __attribute__((fallthrough));

// suppress warnings for variable declaration after label (and allow pre-c23 compilers)
#define do_nothing() \
    do { \
    } while(0)

// TODO
//static inline Strv bool_print(bool condition) {
//    if (condition) {
//        return sv("true");
//    }
//    return sv("false");
//}

#define array_count(array) (sizeof(array)/sizeof((array)[0]))

#define array_at(array, index) \
    (unwrap((index) < array_count(array) && "out of bounds"), (array)[index])

#define array_at_ref(array, index) \
    (unwrap((index) < array_count(array) && "out of bounds"), &(array)[index])

#define INLINE static inline __attribute__((always_inline))

#define NEVER_RETURN __attribute__((noreturn))

#define WSWITCH_ENUM_IGNORE_START \
    _Pragma("GCC diagnostic ignored \"-Wswitch-enum\"")

#define WIMPLICIT_FALLTHROUGH_IGNORE_START \
    _Pragma("GCC diagnostic ignored \"-Wimplicit-fallthrough\"")

#define WSIGN_CONVERSION_IGNORE_START \
    _Pragma("GCC diagnostic ignored \"-Wsign-conversion\"")

#ifdef OWN_WERROR
#   define WSWITCH_ENUM_IGNORE_END \
        _Pragma("GCC diagnostic error \"-Wswitch-enum\"")
#   define WIMPLICIT_FALLTHROUGH_IGNORE_END \
        _Pragma("GCC diagnostic error \"-Wimplicit-fallthrough\"")
#   define WSIGN_CONVERSION_IGNORE_END \
        _Pragma("GCC diagnostic error \"-Wsign-conversion\"")
#else
#   define WSWITCH_ENUM_IGNORE_END \
        _Pragma("GCC diagnostic warning \"-Wswitch-enum\"")
#   define WIMPLICIT_FALLTHROUGH_IGNORE_END \
        _Pragma("GCC diagnostic warning \"-Wimplicit-fallthrough\"")
#   define WSIGN_CONVERSION_IGNORE_END \
        _Pragma("GCC diagnostic warning \"-Wsign-conversion\"")
#endif // OWN_WERROR

static inline void unwrap_internal(bool cond, const char* cond_text, const char* file, int line) {
    if (!(cond)) {
        log_internal(LOG_FATAL, file, line, 0, "condition \"%s\" failed\n", cond_text);
        abort();
    }
}

#define unwrap(cond) unwrap_internal(cond, #cond, __FILE__, __LINE__)

extern Env env;
extern char PATH_SEPARATOR;

// TODO: move this?
typedef size_t Scope_id;

#ifndef INDENT_WIDTH
#define INDENT_WIDTH 2
#endif // INDENT_WIDTH

// TODO: consider if this is the ideal place
#define SCOPE_TOP_LEVEL 0
#define SCOPE_NOT SIZE_MAX

#define MOD_PATH_STD (sv("std/"))
// MOD_PATH_BUILTIN is used mostly for symbols generated by the compiler itself
#define MOD_PATH_BUILTIN (sv("builtin"))
// MOD_PATH_RUNTIME is used for standard library functions that are used by the compiler itself
#define MOD_PATH_RUNTIME (sv("std/runtime")) /* TODO: try to avoid hardcoding path separator? */
#define MOD_PATH_PRELUDE (sv("std/prelude"))
#define MOD_PATH_OF_MOD_PATHS (sv("std/does_not_exist/mod_paths"))
#define MOD_PATH_ARRAYS (sv("std/does_not_exist/arrays"))
#define MOD_PATH_AUX_ALIASES (sv("std/does_not_exist/aux_aliases"))

#define MOD_PATH_EXTERN_C ((Strv) {0})

#define MOD_ALIAS_BUILTIN name_new(MOD_PATH_BUILTIN, sv("mod_aliases"), (Ulang_type_darr) {0}, SCOPE_TOP_LEVEL)
#define MOD_ALIAS_TOP_LEVEL name_new(MOD_PATH_BUILTIN, sv("mod_aliases_top_level"), (Ulang_type_darr) {0}, SCOPE_TOP_LEVEL)
#define MOD_ALIAS_PRELUDE name_new(MOD_PATH_BUILTIN, sv("mod_aliases_prelude"), (Ulang_type_darr) {0}, SCOPE_TOP_LEVEL)

#define EXTERN_C_OWN_PREFIX "own"

// TODO: move this?
#define BUILTIN_DEFS_COUNT 4

#define FMT "%.*s"

#define PATH_SEPARATOR '/'

#define MOD_PATH_COMMAND_LINE sv("std/does_not_exist/cmd")

#define DEFAULT_BUILD_DIR "own_build"

#endif // UTIL_H
