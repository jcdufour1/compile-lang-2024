#
, operator (like in "vec_at" macro)
should := be assignment operator?



# generics
for generics:
    check_<whatever> should see if constraints qualify template parameter
    if assigning template parameter to i32, call get_constraints_lang_type(i32), and compare that way

## miscellaneous 
- lang_type suffix/prefix should be changed to ulang_type in some functions?
- symbol_at function, whatever
- separate lang_type for Llvm stuff
- tuple on lhs changed to individual accesses in type_checking pass?
- fix this to report also the (<i32>) to reduce confusion:
  optional_for_loop.own:150:57:error:argument is of type `u8*`, but the corresponding parameter `num` is of type `i32`
     149 |     let num2 i33 = 5
     150 |     printf("test 40: got number: %d\n", triangle(<i32>)("sdfa"))
         |                                                         ^
     151 |     printf("test 41: got number: %d\n", triangle(<i32>)(num3 + 2))
  src/type_checking.c:1463:debug:location of error
  optional_for_loop.own:48:25:note:corresponding parameter `num` defined here
      47 |
      48 | fn triangle(<ItemType>)(num ItemType) ItemType {
         |                         ^
      49 |     let result ItemType = 0
- test cases for variable def after use
- rename examples/new_lang/if_expression.own to examples/new_lang/if_statement.own
- make actual if_expression test
- make expected failure test for using variable to assign self in initialization
    (eg. let num i32 = num*4)
- struct and sum with same elements, etc. to stress test some things
- make expected failure test case for this:
      import = std
- expected failure case for importing file that does not exist
- print function for vector of something
- test case for this in generic function:
    return Optional(<ItemType>).some(num + 1)
- rename atom.str to atom.name
- put import_path in different name space from other things
- do_test.py shold fail if thing with invalid extension found in tests/* or examples/new_lang/
- disallow literal int implicit conversion to i32 in generic?
- Uast_mod_alias: use Str_view for mod_path?
- expected success case for circular import
- should I use syntax:
  type Token struct {
  }
  type get_token fn
  instead of:
  type Token struct {
  }
  fn get_token
- make an assertion that tests/expected_failure_examples/expected_expr_at_end_of_file.own has no newlines or similar characters after `io.`
- make an assertion that tests/expected_failure_examples/empty_file.own actually is empty
- expected failure test for passing `fn (i32, i32) i32` to function parameter of `fn (i64, i64) i64`
- expected failure test for empty []
- make actual way to designate some test inputs as unfinished (after doing this, make some files unfinished)
- make system to store compiler source code location of generated uasts, tasts, and llvms on debug mode
-- c code generated should have comments saying if goto was generated by break, etc.
- do_test.py: set limit on captured stdout if possible (to prevent exhausting all system resources on infinite loop)?
- more documentation on internals and conventions
- decide if reassigning index variable in for loop should be allowed
- be more consistant with src or rhs
- fix ./tests2/inputs/test_basic.own (outer loop should break after first iteration, because of num1 = 8 assignment)
- make ignored tests feature
- expected failure test for more than one generic parameter with the same name?
- expected failure case for generic argument having default argument
- expected failure case for invalid return type or parameter types for main function
- more util functions should be in .c file instead of .h file to make things easier

# roadmap to try to get bootstrap compiler done:
## needed features
- argv
- constraints in generics
- slices
- orelse, !!, ??, etc.
- extern("c") defintions
- non-hard coded size_t, etc.
- printing features
- global constants
- way to get tag of sum (be sure that checking if sums are equal is possible)
- mandatory initialization or similar
- manual zero initialization
- safe cast (use "cast(<i64>)" to cast num to i64)?
- prevent collisions with user defined names and compiler defined names
- test for break in switch case 
- distinct
- pointer generic
- warn about unused variables
- when using variadic args for extern("c") function: give error when passing i16 without a cast, etc.
- implement == for sum with void inner types, or give error for using ==
- test case for: let num f32 = 7
- binary operators with f64 literals on both sides (precomputation)
- fix this to say f32 instead of std/raylib::f32:
    main.own:15:39:error:type `u1` cannot be implicitly converted to `std/raylib::f32`
        14 |         rl.ClearBackground(rl.BLACK());
        15 |         rl.DrawRectangleLinesEx({0.0, 0, 100, 100}, 0x40400000, rl.RED())
           |                                       ^
        16 |
- consider renaming Llvm_store_another_llvm to Llvm_store
- consider renaming Llvm_load_another_llvm to Llvm_load
- expected failure case for:
    // Div is a struct
    let div Div = .num(9)
- expected failure case for invalid label at the end of the file:
    hello: i32
- expected failure test for:
continue(<thing>)
-tests for ir printing
-consider if this is good enough syntax for passing generic function callback:
add_fn(<i16>)
- literal suffixes
- use DIAG_ERROR for things that must be an error?
- figure out why this causes redefinition error: (maybe uast_case should always contain block internally to fix this bug?)
    switch rhs {
        case .some(rhs_val):
            if let .some(lhs_val) = lhs {
                return lhs_val + rhs_val
            } else {
                return rhs_val
            }
        case .none:
            if let .some(lhs_val) = lhs {
                return lhs_val
            } else {
                return 0
            }
    }
- info logs do not seem to be logged when specifying "--set-log-level=INFO" on the command line?
- expected failure test for invalid type in unsafe_cast
- move std/std_dummy* items from std directory to a different directory
- improve immediate representation dump so that it is actually readable
- error message when specifing module that does not exist
- this should not cause redefinition error:
    type darr import = arr
    fn main() i32 {
        let arr darr.Arr(<i32>)
        return 0
    }
- when printing msg, use name instead of uname to make types show pretty (and remove uname_normalize function?)
- make separate UNARY_TYPE and BINARY_TYPE for Ir (to make it easier to manage backends)
- make print functions check for null and print <null> or something instead of seg fault
- figure out if I should de-duplilcate string literals, etc.
- strings should actually be their own type (not just u8*) (maybe slice with null termination)
- fix printing for lang_type in msg to not put newline
- actually use newline to end statement depending on last token of line of line
- expected failure case for invalid type in extern "c" function
- when showing error for file not opening while importing module, show note for import location
- figure out why this function causes compiler to crash ("column = column" used instead of ".column = column"):
    fn arr_new(max_capacity u64, ItemT Type, init_elems Slice(<ItemT>) = [], file u8* = #file, line i32 = #line, column i32 = #column) Arr(<ItemT>) {
        let buf ItemT* = unsafe_cast<ItemT*>util.malloc(sizeof(ItemT)*max_capacity)
        util.assert(buf != unsafe_cast<Token*>0, "out of memory", .file = file, .line = line, .column = column)
        let arr Arr(<ItemT>) = {buf, 0, max_capacity}
        arr_extend(&arr, init_elems, .file = file, .line = line, column = column)
        return arr
    }
- test case for local struct with the same base name (Name->base) as std struct, and use std struct (be sure that compiler actually differenciates between the two)
    eg. (coll.arr_new accepts std::collections::arr_new)
    type coll import = std.collections
    type Slice struct(<ItemT>) {
        buf ItemT*
        count u64
    }
    fn main() i32 {
        let slice coll.Slice(<i32>) = [9, 8]
        let arr2 coll.Arr(<i32>) = coll.arr_new(5, i32, slice)
        return 0
    }
- expected failure test case for:
    fn main() i32 {
        return 0
    }
    }
- allow if body (single statement) to be on the same line as if condition using => or similar
    this could be accomplished by parsing single statement in parse_block function if `=>` encountered,
    this way => can also be used in switch, function definition, etc.






## needed tests
- let token* Token = <...>; switch token {<...>}

# optional things:
- const, etc.
- graphviz (for program control flow, etc.)
- foreach idea:
  fn foreach_tokens(tokens Token[]) {
    for idx i64 in tokens {
        yield tokens[idx]
    }
  }
- bit widths other than 1, 8, 16, 32, or 64 with the c backend
- when generics are mature, use them to associate custom allocators with things
- for testing: make overview grid that uses one letter per test to make it easier to see what tests pass
- windows support (including ci)
- support alternative backend

# in the far future
- try catch blocks with the question operator or similar
