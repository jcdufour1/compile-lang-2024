#
, operator (like in "vec_at" macro)
should := be assignment operator?



# generics
for generics:
    check_<whatever> should see if constraints qualify template parameter
    if assigning template parameter to i32, call get_constraints_lang_type(i32), and compare that way

# directory stucture
- util
- tokenizer
- parser
- load
- codegen

## miscellaneous 
- lang_type suffix/prefix should be changed to ulang_type in some functions?
- directory structure above
- symbol_at function, whatever
- separate lang_type for Llvm stuff
- tuple on lhs changed to individual accesses in type_checking pass?
- fix this to report also the (<i32>) to reduce confusion:
  optional_for_loop.own:150:57:error:argument is of type `u8*`, but the corresponding parameter `num` is of type `i32`
     149 |     let num2 i33 = 5
     150 |     printf("test 40: got number: %d\n", triangle(<i32>)("sdfa"))
         |                                                         ^
     151 |     printf("test 41: got number: %d\n", triangle(<i32>)(num3 + 2))
  src/type_checking.c:1463:debug:location of error
  optional_for_loop.own:48:25:note:corresponding parameter `num` defined here
      47 |
      48 | fn triangle(<ItemType>)(num ItemType) ItemType {
         |                         ^
      49 |     let result ItemType = 0
- test cases for variable def after use
- rename examples/new_lang/if_expression.own to examples/new_lang/if_statement.own
- make actual if_expression test
- make expected failure test for using variable to assign self in initialization
    (eg. let num i32 = num*4)
- struct and sum with same elements, etc. to stress test some things
- make expected failure test case for this:
      import = std
- expected failure case for importing file that does not exist
- print function for vector of something
- test case for this in generic function:
    return Optional(<ItemType>).some(num + 1)
- rename atom.str to atom.name
- put import_path in different name space from other things
- do_test.py shold fail if thing with invalid extension found in tests/* or examples/new_lang/
- disallow literal int implicit conversion to i32 in generic?
- Uast_mod_alias: use Str_view for mod_path?
- expected success case for circular import
- should I use syntax:
  type Token struct {
  }
  type get_token fn
  instead of:
  type Token struct {
  }
  fn get_token
- make an assertion that tests/expected_failure_examples/expected_expr_at_end_of_file.own has no newlines or similar characters after `io.`
- make an assertion that tests/expected_failure_examples/empty_file.own actually is empty
- expected failure test for passing `fn (i32, i32) i32` to function parameter of `fn (i64, i64) i64`
- expected failure test for empty []
- make actual way to designate some test inputs as unfinished (after doing this, make some files unfinished)
- make system to store compiler source code location of generated uasts, tasts, and llvms on debug mode
-- c code generated should have comments saying if goto was generated by break, etc.
- do_test.py: set limit on captured stdout if possible (to prevent exhausting all system resources on infinite loop)?
- more documentation on internals and conventions
- decide if reassigning index variable in for loop should be allowed
- be more consistant with src or rhs
- fix ./tests2/inputs/test_basic.own (outer loop should break after first iteration, because of num1 = 8 assignment)
- make ignored tests feature
- expected failure test for more than one generic parameter with the same name?
- expected failure case for generic argument having default argument

# roadmap to try to get bootstrap compiler done:
## needed features
- constraints in generics
- slices
- orelse, !!, ??, etc.
- extern("c") defintions
- non-hard coded size_t, etc.
- printing features
- global constants
- way to get tag of sum (be sure that checking if sums are equal is possible)
- mandatory initialization or similar
- manual zero initialization
- safe cast (use "cast(<i64>)" to cast num to i64)?
- prevent collisions with user defined names and compiler defined names
- test for break in switch case 
- distinct
- pointer generic
- warn about unused variables
- when using variadic args for extern("c") function: give error when passing i16 without a cast, etc.
- implement == for sum with void inner types, or give error for using ==
- test case for: let num f32 = 7
- 7_000.001
- binary operators with f64 literals on both sides (precomputation)
- fix this to say f32 instead of std/raylib::f32:
    main.own:15:39:error:type `u1` cannot be implicitly converted to `std/raylib::f32`
        14 |         rl.ClearBackground(rl.BLACK());
        15 |         rl.DrawRectangleLinesEx({0.0, 0, 100, 100}, 0x40400000, rl.RED())
           |                                       ^
        16 |
- make shorter function name for `str_view_from_cstr`, because this function is used so much
- command line interface idea:
### compile
main hello.own
### run
main hello.own --run arg1 arg2 ..
- consider renaming Llvm_store_another_llvm to Llvm_store
- consider renaming Llvm_load_another_llvm to Llvm_load
- expected failure case for redefiniton of members in enum and struct
- expected failure case for:
    // Div is a struct
    let div Div = .num(9)
- expected failure case for invalid label at the end of the file:
    hello: i32
- expected failure test for:
continue(<thing>)
-tests for ir printing
-consider if this is good enough syntax for passing generic function callback:
add_fn(<i16>)
    


## needed tests
- let token* Token = <...>; switch token {<...>}

# optional things:
- const, etc.
- named scopes
- designated args
- graphviz (for program control flow, etc.)
- foreach idea:
  fn foreach_tokens(tokens Token[]) {
    for idx i64 in tokens {
        yield tokens[idx]
    }
  }
- bit widths other than 1, 8, 16, 32, or 64 with the c backend
- when generics are mature, use them to associate custom allocators with things

# in the far future
- try catch blocks with the question operator or similar
