#
, operator (like in "vec_at" macro)
should := be assignment operator?



# generics
for generics:
    check_<whatever> should see if constraints qualify template parameter
    if assigning template parameter to i32, call get_constraints_lang_type(i32), and compare that way

# directory stucture
- util
- tokenizer
- parser
- load
- codegen

## miscellaneous 
- lang_type suffix/prefix should be changed to ulang_type in some functions?
- directory structure above
- symbol_at function, whatever
- separate lang_type for Llvm stuff
- fix lang_type system for void, etc. (it is a mess)
- tuple on lhs changed to individual accesses in type_checking pass?
- fix this to report also the (<i32>) to reduce confusion:
  optional_for_loop.own:150:57:error:argument is of type `u8*`, but the corresponding parameter `num` is of type `i32`
     149 |     let num2 i33 = 5
     150 |     printf("test 40: got number: %d\n", triangle(<i32>)("sdfa"))
         |                                                         ^
     151 |     printf("test 41: got number: %d\n", triangle(<i32>)(num3 + 2))
  src/type_checking.c:1463:debug:location of error
  optional_for_loop.own:48:25:note:corresponding parameter `num` defined here
      47 |
      48 | fn triangle(<ItemType>)(num ItemType) ItemType {
         |                         ^
      49 |     let result ItemType = 0
- test cases for variable def after use
- env: should always or never pass to function
- pos in lang_type struct should actually be initalized to meaningful value
- rename examples/new_lang/if_expression.own to examples/new_lang/if_statement.own
- make actual if_expression test
- make expected failure test for using variable to assign self in initialization
    (eg. let num i32 = num*4)
- rename ULANG_TYPE_REG_GENERIC to ULANG_TYPE_GENERIC
- struct and sum with same elements, etc. to stress test some things
- make expected failure test case for this:
      import = std
- expected failure case for importing file that does not exist
- print function for vector of something
- test case for this in generic function:
    return Optional(<ItemType>).some(num + 1)
- rename atom.str to atom.name
- put import_path in different name space from other things
- do_test.py shold fail if thing with invalid extension found in tests/* or examples/new_lang/
- disallow literal int implicit conversion to i32 in generic?
- Uast_mod_alias: use Str_view for mod_path?
- test for empty file
- expected success test case for:
    for !rl.WindowShouldClose() {
    }
- expected success case for circular import
- should I use syntax:
  type Token struct {
  }
  type get_token fn
  instead of:
  type Token struct {
  }
  fn get_token
- make LLVM_LANG_TYPE, etc. that does not have LANG_TYPE_ENUM, etc.



# roadmap to try to get bootstrap compiler done:
## needed features
- nested generics
- constraints in generics
- defer
- modules
- slices
- orelse, !!, ??, etc.
- #pos to get position
- extern("c") defintions
- non-hard coded size_t, etc.
- printing features
- global constants
- way to get tag of sum (be sure that checking if sums are equal is possible)
- mandatory initialization or similar
- manual zero initialization
- safe cast (use "i64(num)" to cast num to i64)?
- prevent collisions with user defined names and compiler defined names
- test for break in switch case 
- use str_view_at instead of str_view.str[idx] for bounds checking
- def
- distinct
- pointer generic
- warn about unused variables
- invalid literal as function callee


## needed tests
- let token* Token = <...>; switch token {<...>}

# optional things:
- const, etc.
- named scopes
- designated args
- iterators and foreach
- floats
- use 0o for octal prefix?
- graphviz (for program control flow, etc.)
- foreach idea:
- fn foreach_tokens(tokens Token[]) {
    for idx i64 in tokens {
        yield tokens[idx]
    }
  }

