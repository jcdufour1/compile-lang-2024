#
, operator (like in "vec_at" macro)
should := be assignment operator?



# generics
for generics:
    check_<whatever> should see if constraints qualify template parameter
    if assigning template parameter to i32, call get_constraints_lang_type(i32), and compare that way

# directory stucture
- util
- tokenizer
- parser
- load
- codegen

## miscellaneous 
- lang_type suffix/prefix should be changed to ulang_type in some functions?
- directory structure above
- symbol_at function, whatever
- separate lang_type for Llvm stuff
- tuple on lhs changed to individual accesses in type_checking pass?
- fix this to report also the (<i32>) to reduce confusion:
  optional_for_loop.own:150:57:error:argument is of type `u8*`, but the corresponding parameter `num` is of type `i32`
     149 |     let num2 i33 = 5
     150 |     printf("test 40: got number: %d\n", triangle(<i32>)("sdfa"))
         |                                                         ^
     151 |     printf("test 41: got number: %d\n", triangle(<i32>)(num3 + 2))
  src/type_checking.c:1463:debug:location of error
  optional_for_loop.own:48:25:note:corresponding parameter `num` defined here
      47 |
      48 | fn triangle(<ItemType>)(num ItemType) ItemType {
         |                         ^
      49 |     let result ItemType = 0
- test cases for variable def after use
- rename examples/new_lang/if_expression.own to examples/new_lang/if_statement.own
- make actual if_expression test
- make expected failure test for using variable to assign self in initialization
    (eg. let num i32 = num*4)
- struct and sum with same elements, etc. to stress test some things
- make expected failure test case for this:
      import = std
- expected failure case for importing file that does not exist
- print function for vector of something
- test case for this in generic function:
    return Optional(<ItemType>).some(num + 1)
- rename atom.str to atom.name
- put import_path in different name space from other things
- do_test.py shold fail if thing with invalid extension found in tests/* or examples/new_lang/
- disallow literal int implicit conversion to i32 in generic?
- Uast_mod_alias: use Str_view for mod_path?
- expected success case for circular import
- should I use syntax:
  type Token struct {
  }
  type get_token fn
  instead of:
  type Token struct {
  }
  fn get_token
- make LLVM_LANG_TYPE, etc. that does not have LANG_TYPE_ENUM, etc.
- make an assertion that tests/expected_failure_examples/expected_expr_at_end_of_file.own has no newlines or similar characters after `io.`
- make an assertion that tests/expected_failure_examples/empty_file.own actually is empty
- expected failure test for passing `fn (i32, i32) i32` to function parameter of `fn (i64, i64) i64`
- expected failure test for empty []
- consider if tokenizer should convert semicolon to newline to simplify things
- make actual way to designate some test inputs as unfinished (after doing this, make some files unfinished)
- remove enum, then eventually rename sum to enum (this can simplify maintenance, etc.)


# roadmap to try to get bootstrap compiler done:
## needed features
- constraints in generics
- defer
- slices
- orelse, !!, ??, etc.
- #pos to get position
- extern("c") defintions
- non-hard coded size_t, etc.
- printing features
- global constants
- way to get tag of sum (be sure that checking if sums are equal is possible)
- mandatory initialization or similar
- manual zero initialization
- safe cast (use "cast(<i64>)" to cast num to i64)?
- prevent collisions with user defined names and compiler defined names
- test for break in switch case 
- distinct
- pointer generic
- warn about unused variables
- when using variadic args for extern("c") function: give error when passing i16 without a cast, etc.
- consistent naming for arenas


## needed tests
- let token* Token = <...>; switch token {<...>}

# optional things:
- use 0o for octal prefix?
- const, etc.
- named scopes
- designated args
- floats
- graphviz (for program control flow, etc.)
- foreach idea:
  fn foreach_tokens(tokens Token[]) {
    for idx i64 in tokens {
        yield tokens[idx]
    }
  }
- bit widths other than 1, 8, 16, 32, or 64 with the c backend
- when generics are mature, use them to associate custom allocators with things

# in the far future
- try catch blocks with the question operator or similar
