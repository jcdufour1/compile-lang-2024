

# generics
for generics:
    check_<whatever> should see if constraints qualify template parameter
    if assigning template parameter to i32, call get_constraints_lang_type(i32), and compare that way

## miscellaneous 
- lang_type suffix/prefix should be changed to ulang_type in some functions?
- tuple on lhs changed to individual accesses in type_checking pass?
- fix this to report also the (<i32>) to reduce confusion?:
  optional_for_loop.own:150:57:error:argument is of type `u8*`, but the corresponding parameter `num` is of type `i32`
     149 |     let num2 i33 = 5
     150 |     printf("test 40: got number: %d\n", triangle(<i32>)("sdfa"))
         |                                                         ^
     151 |     printf("test 41: got number: %d\n", triangle(<i32>)(num3 + 2))
  src/type_checking.c:1463:debug:location of error
  optional_for_loop.own:48:25:note:corresponding parameter `num` defined here
      47 |
      48 | fn triangle(<ItemType>)(num ItemType) ItemType {
         |                         ^
      49 |     let result ItemType = 0
- test cases for variable def after use
- rename examples/new_lang/if_expression.own to examples/new_lang/if_statement.own
- make actual if_expression test
- print function for vector of something
- rename atom.str to atom.name
- do_test.py shold fail if thing with invalid extension found in tests/* or examples/new_lang/
- make an assertion that tests/expected_failure_examples/expected_expr_at_end_of_file.own has no newlines or similar characters after `io.`
- make an assertion that tests/expected_failure_examples/empty_file.own actually is empty
- expected failure test for passing `fn (i32, i32) i32` to function parameter of `fn (i64, i64) i64`
- make system to store compiler source code location of generated uasts, tasts, and irs on debug mode
-- c code generated should have comments saying if goto was generated by break, etc.
- do_test.py: set limit on captured stdout if possible (to prevent exhausting all system resources on infinite loop)?
- more documentation on internals and conventions
- decide if reassigning index variable in for loop should be allowed
- be more consistant with src or rhs
- fix ./tests2/inputs/test_basic.own (outer loop should break after first iteration, because of num1 = 8 assignment)
- make ignored tests feature?
- expected failure test for more than one generic parameter with the same name?
- expected failure case for generic argument having default argument
- expected failure case for invalid return type or parameter types for main function
- more util functions should be in .c file instead of .h file to make things easier
- see if error for invalid function arg type can print both dest and src to reduce confusion
    it could also help to print function name that is problem in actual error (not only in note)
- test case for:
    io.printf("%.*s:%d:%d\n", #file.count, (#file).buf, #line, #column);
- tests/inputs/arr_append_gen_type.own: defer arr_free to free memory
- imporove ir printing
- make .own directory (or similar) for build artifacts and put .gitignore file in .own directory
- ** operator (pow)
- figure out how to handle redefinition of extern c functions
- make ir output more readable:
    -- label should be indented
    -- literal should be printed as literal instead of as just name
    -- have proper delimeters (eg. space)
- for below, figure out why order is wrong:
    tests/inputs/uninitialized.own:47:19:note:tracing path of uninitialized variable use
        46 |     switch way {
        47 |         case .way1: break
           |                   ^
        48 |         case .way2: status = 4
    tests/inputs/uninitialized.own:46:5:note:tracing path of uninitialized variable use
        45 |     let status i32
        46 |     switch way {
           |     ^
        47 |         case .way1: break
- proper print functions for Ulang_type_regular, etc.
- this can crash the compiler (because of the i32):
    io.printf("before 1: %d\n", *rt.static_array_access(nums, idx), "\n", i32)
- this operation should not return type f32:
    8.7 <= 7.7
- this operation should not be allowed (or should give warning):
    let lhs f32 = 8.6
    let rhs f32 = 8.4
    lhs == rhs
- assert statement to catch mod_path (other than MOD_PATH_BUILTIN) used for primitive types
- top level of file should actually have SCOPE_TOP_LEVEL?
    (for this to work, scope_iter function needs to consider mod path in addition to scope_id)
- "_1__7_builtin_str____2658" could be printed as "7builtin_str2658", 
    because variable names cannot start with digit anyway, and there is no need to encode pointer depth
- fix this parser bug:
    if curr < '0' || curr > '9' => break
    *str = slice_range(*str, 1, str.count - 1)
- ptr depth should be implemented using lang_type_ptr instead of storing ptr depth in atom?
    lang_type_ptr could have depth variable to reduce number of lang_type_ptrs needed
- TODO: size_t may not be the correct type
     for lang_type_array.count, because
     lang_type_array.count is not
     nessessarily based on memory size
     of computer that compilation happens
- check for return statement on all code paths
- possible optimizations to save memory:
    -- use bitsets
    -- save Pos as 48 or 64 bit var
    -- make size_t as 48 bit var?
    -- make Name be stored as pointer or offset in structs instead of by value?
    -- better arena management
    -- use views instead of vecs in ast and ir nodes?
    -- tokenizer could tokenize as parsing happens (with look ahead of about 3 tokens) instead of getting all tokens of file at once
- test case for int value being used as lang_type generic arg and vice versa
- if using "--no-prelude", and prelude functionality is still used anyway, the compiler should print
    proper error instead of crashing
- member_name of member access should not be substituted in generic substitution
- do_test.py should have confirmation before update
- check that the main function has the correct signature (make expected failure test)
- check that there are not duplicate main functions (make expected failure test)
- store pos in Uast_struct_def_base?
- store pos in Tast_struct_def_base?
- in examples/calculator.own:13 ("for idx u64 in 0..amt_consumed => io.print_str(" ", "")"), I should
     be able to remove u64. fix bug that prevents it from being possible.
- figure out why this does not work:
    fn do_nothing(pretend_fn fn()) {
- allow struct literal designated args to be in any order
- float generic args: make sure that duplicate functions are not being created because of floating point rounding errors
- expected failure case for generic parameter having the same name as top level function
- add token `::`?
- add token `:=`?
- change `if let` to use `:=`
- make better hash table system (use autogen or use library)
- see if a_temp can be used in autogen. If not, do refactoring so that a_temp can be used in autogen
- document or make functions for uast_def_get_ulang_type
- make test case for passing args after --run and using argv in program
- test case for def alias used within struct literal generic arg
- make expected success test for strange input name (eg. "tests/inputs/thing&-.own")?
- implement non top level structs (do by making top level struct with util_literal_name_new(), then make def in scope of user struct def)
- in autogen_(u||ir)lang_type, call common function after generating (u||ir)lang_type
- add prefix to symbols when emitting backend IR (start with double underscore, etc.) to prevent collisions
- fix uninitialized warning with gcc (could be gcc bug?)
- add methods?
- todo should call local_exit?
- def should be defined this way?:
    EOF :: def -1
- remove let keyword from syntax file
- remove let token type
- this error message should say "did you mean to add `:` after `Raw1`"
    - tests/inputs/sizeof.own:154:10:error:expected newline after statement
       153 |
       154 |     raw1 Raw1
- change import syntax to 
    io :: import std.io
- test log level in ci
- make loc printing work for uasts and tasts



# roadmap to try to get bootstrap compiler done:
## needed features
- directive to run code at compile time
- tuples
- tutorial (place in tutorial directory, etc. start file names with 001, etc.)
- constraints in generics
- orelse, !!, ??, etc.
- extern("c") defintions
- printing features
- global constants
- global variables
- way to get tag of sum (be sure that checking if sums are equal is possible)
- std function for manual zero initialization
- safe cast (use "cast(<i64>)" to cast num to i64, or use go style casting (eg. "i64(num)")?
- test for break in switch case 
- distinct
- pointer generic
- warn about unused variables
- when using variadic args for extern("c") function: give error when passing i16 without a cast, etc.
- implement == for sum with void inner types, or give error for using ==
- test case for: let num f32 = 7
- binary operators with f64 literals on both sides (precomputation)
- consider renaming Llvm_store_another_llvm to Llvm_store
- consider renaming Llvm_load_another_llvm to Llvm_load
- expected failure case for:
    // Div is a struct
    let div Div = .num(9)
- expected failure case for invalid label at the end of the file:
    hello: i32
- expected failure test for:
continue(<thing>)
-tests for ir printing
- literal suffixes
- use DIAG_ERROR for things that must be an error?
- expected failure test for invalid type in unsafe_cast
- improve immediate representation dump so that it is actually readable
- make print functions check for null and print <null> or something instead of seg fault
- figure out if I should de-duplilcate string literals, etc.
- fix printing for lang_type in msg to not put newline
- expected failure case for invalid type in extern "c" function
- expected success test that excaped " is supported in string literal
- write documentation
- documentation should note that using can emulate inheritance in structs (I also need expected
    success test case for that)
- use libclang to get extern c declarations automatically
- use libclang for help with c abi (so that i can actually use llvm?)
- use libclang to get size of c types (and use size of c types stored locally in project as fallback)
- use c89 for the c backend instead of c99 for better compatibility
- stop using todo macro in main branch?





## needed tests
- let token* Token = <...>; switch token {<...>}

# optional things:
- const, etc.
- graphviz (for program control flow, etc.)
- foreach idea:
  fn foreach_tokens(tokens Token[]) {
      for idx in 0..tokens.count {
          for_yield tokens[idx]
      }
  }
- bit widths other than 1, 8, 16, 32, or 64 with the c backend
- use generics to associate custom allocators with things?
- for testing: make overview grid that uses one letter per test to make it easier to see what tests pass
- windows support (including ci)
- support alternative backend
- make single colon and double colon separate token types


# in the far future
- try catch blocks with the question operator or similar
- dynamic dispatch in generics (function pointers, constant expressions, etc. should be stored in 
    table; there should be one table per generic variant)
- function to set break point in source code (eg. `breakpoint`)
- use own calling convention
    - types larger than 16 bytes should by passed by pointer?
- array of structs and structs of array options
