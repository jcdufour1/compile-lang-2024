#
, operator (like in "vec_at" macro)
should := be assignment operator?



# generics
for generics:
    check_<whatever> should see if constraints qualify template parameter
    if assigning template parameter to i32, call get_constraints_lang_type(i32), and compare that way

## miscellaneous 
- lang_type suffix/prefix should be changed to ulang_type in some functions?
- symbol_at function, whatever
- tuple on lhs changed to individual accesses in type_checking pass?
- fix this to report also the (<i32>) to reduce confusion:
  optional_for_loop.own:150:57:error:argument is of type `u8*`, but the corresponding parameter `num` is of type `i32`
     149 |     let num2 i33 = 5
     150 |     printf("test 40: got number: %d\n", triangle(<i32>)("sdfa"))
         |                                                         ^
     151 |     printf("test 41: got number: %d\n", triangle(<i32>)(num3 + 2))
  src/type_checking.c:1463:debug:location of error
  optional_for_loop.own:48:25:note:corresponding parameter `num` defined here
      47 |
      48 | fn triangle(<ItemType>)(num ItemType) ItemType {
         |                         ^
      49 |     let result ItemType = 0
- test cases for variable def after use
- rename examples/new_lang/if_expression.own to examples/new_lang/if_statement.own
- make actual if_expression test
- make expected failure test for using variable to assign self in initialization
    (eg. let num i32 = num*4)
    (this will be done by having pass to check for uninitialized)
- struct and sum with same elements, etc. to stress test some things
- make expected failure test case for this:
      import = std
- expected failure case for importing file that does not exist
- print function for vector of something
- rename atom.str to atom.name
- put import_path in different name space from other things
- do_test.py shold fail if thing with invalid extension found in tests/* or examples/new_lang/
- make an assertion that tests/expected_failure_examples/expected_expr_at_end_of_file.own has no newlines or similar characters after `io.`
- make an assertion that tests/expected_failure_examples/empty_file.own actually is empty
- expected failure test for passing `fn (i32, i32) i32` to function parameter of `fn (i64, i64) i64`
- expected failure test for empty []
- make actual way to designate some test inputs as unfinished (after doing this, make some files unfinished)
- make system to store compiler source code location of generated uasts, tasts, and llvms on debug mode
-- c code generated should have comments saying if goto was generated by break, etc.
- do_test.py: set limit on captured stdout if possible (to prevent exhausting all system resources on infinite loop)?
- more documentation on internals and conventions
- decide if reassigning index variable in for loop should be allowed
- be more consistant with src or rhs
- fix ./tests2/inputs/test_basic.own (outer loop should break after first iteration, because of num1 = 8 assignment)
- make ignored tests feature
- expected failure test for more than one generic parameter with the same name?
- expected failure case for generic argument having default argument
- expected failure case for invalid return type or parameter types for main function
- more util functions should be in .c file instead of .h file to make things easier
- see if error for invalid function arg type can print both dest and src to reduce confusion
    it could also help to print function name that is problem in actual error (not only in note)
- test case for:
    io.printf("%.*s:%d:%d\n", #file.count, (#file).buf, #line, #column);
- allow passing pointer type (eg. "Token(<i32, u8*>)*") into function arg
- tests/inputs/arr_append_gen_type.own: defer arr_free to free memory
- error for using `def` in std/runtime.own (or figure out way to make defs work there)
- make command line argument to not import any libraries (even runtime) to make debugging easier
- imporove ir printing
- make .own directory (or similar) for build artifacts and put .gitignore file in .own directory
- ** operator (pow)
- figure out how to handle redefinition of extern c functions
- proper print functions for Ulang_type_regular, etc.
- this can crash the compiler (because of the i32):
    io.printf("before 1: %d\n", *rt.static_array_access(nums, idx), "\n", i32)
- this operation should not return type f32:
    8.7 <= 7.7
- this operation should not be allowed (or should give warning):
    let lhs f32 = 8.6
    let rhs f32 = 8.4
    lhs == rhs
- assert statement to catch mod_path (other than MOD_PATH_BUILTIN) used for primitive types

# roadmap to try to get bootstrap compiler done:
## needed features
- constraints in generics
- slices
- orelse, !!, ??, etc.
- extern("c") defintions
- non-hard coded size_t, etc.
- printing features
- global constants
- global variables
- way to get tag of sum (be sure that checking if sums are equal is possible)
- mandatory initialization or similar
- manual zero initialization
- safe cast (use "cast(<i64>)" to cast num to i64)?
- test for break in switch case 
- distinct
- pointer generic
- warn about unused variables
- when using variadic args for extern("c") function: give error when passing i16 without a cast, etc.
- implement == for sum with void inner types, or give error for using ==
- test case for: let num f32 = 7
- binary operators with f64 literals on both sides (precomputation)
- consider renaming Llvm_store_another_llvm to Llvm_store
- consider renaming Llvm_load_another_llvm to Llvm_load
- expected failure case for:
    // Div is a struct
    let div Div = .num(9)
- expected failure case for invalid label at the end of the file:
    hello: i32
- expected failure test for:
continue(<thing>)
-tests for ir printing
-consider if this is good enough syntax for passing generic function callback:
    add_fn(<i16>)
- literal suffixes
- use DIAG_ERROR for things that must be an error?
- expected failure test for invalid type in unsafe_cast
- improve immediate representation dump so that it is actually readable
- make print functions check for null and print <null> or something instead of seg fault
- figure out if I should de-duplilcate string literals, etc.
- fix printing for lang_type in msg to not put newline
- expected failure case for invalid type in extern "c" function
- check for return statement on all code paths
- examples directory should be run through test suite as well?
- "_1__7_builtin_str____2658" could be printed as "7builtin_str2658", 
    because variable names cannot start with digit anyway, and there is no need to encode pointer depth
- fix this parser bug:
    if curr < '0' || curr > '9' => break
    *str = slice_range(*str, 1, str.count - 1)
- fix bug (def not being eliminated when defining Slice of strs this way):
    Slice(<Str>)
- ptr depth should be implemented using lang_type_ptr instead of storing ptr depth in atom?
    lang_type_ptr could have depth variable to reduce number of lang_type_ptrs needed
- TODO: size_t may not be the correct type
     for lang_type_array.count, because
     lang_type_array.count is not
     nessessarily based on memory size
     of computer that compilation happens






## needed tests
- let token* Token = <...>; switch token {<...>}

# optional things:
- const, etc.
- graphviz (for program control flow, etc.)
- foreach idea:
  fn foreach_tokens(tokens Token[]) {
    for idx i64 in tokens {
        yield tokens[idx]
    }
  }
- bit widths other than 1, 8, 16, 32, or 64 with the c backend
- when generics are mature, use them to associate custom allocators with things
- for testing: make overview grid that uses one letter per test to make it easier to see what tests pass
- windows support (including ci)
- support alternative backend


# in the far future
- try catch blocks with the question operator or similar
