#
, operator (like in "vec_at" macro)
should := be assignment operator?



# generics
for generics:
    check_<whatever> should see if constraints qualify template parameter
    if assigning template parameter to i32, call get_constraints_lang_type(i32), and compare that way

## miscellaneous 
- lang_type suffix/prefix should be changed to ulang_type in some functions?
- tuple on lhs changed to individual accesses in type_checking pass?
- fix this to report also the (<i32>) to reduce confusion?:
  optional_for_loop.own:150:57:error:argument is of type `u8*`, but the corresponding parameter `num` is of type `i32`
     149 |     let num2 i33 = 5
     150 |     printf("test 40: got number: %d\n", triangle(<i32>)("sdfa"))
         |                                                         ^
     151 |     printf("test 41: got number: %d\n", triangle(<i32>)(num3 + 2))
  src/type_checking.c:1463:debug:location of error
  optional_for_loop.own:48:25:note:corresponding parameter `num` defined here
      47 |
      48 | fn triangle(<ItemType>)(num ItemType) ItemType {
         |                         ^
      49 |     let result ItemType = 0
- test cases for variable def after use
- rename examples/new_lang/if_expression.own to examples/new_lang/if_statement.own
- make actual if_expression test
- print function for vector of something
- rename atom.str to atom.name
- do_test.py shold fail if thing with invalid extension found in tests/* or examples/new_lang/
- make an assertion that tests/expected_failure_examples/expected_expr_at_end_of_file.own has no newlines or similar characters after `io.`
- make an assertion that tests/expected_failure_examples/empty_file.own actually is empty
- expected failure test for passing `fn (i32, i32) i32` to function parameter of `fn (i64, i64) i64`
- make system to store compiler source code location of generated uasts, tasts, and irs on debug mode
-- c code generated should have comments saying if goto was generated by break, etc.
- do_test.py: set limit on captured stdout if possible (to prevent exhausting all system resources on infinite loop)?
- more documentation on internals and conventions
- decide if reassigning index variable in for loop should be allowed
- be more consistant with src or rhs
- fix ./tests2/inputs/test_basic.own (outer loop should break after first iteration, because of num1 = 8 assignment)
- make ignored tests feature?
- expected failure test for more than one generic parameter with the same name?
- expected failure case for generic argument having default argument
- expected failure case for invalid return type or parameter types for main function
- more util functions should be in .c file instead of .h file to make things easier
- see if error for invalid function arg type can print both dest and src to reduce confusion
    it could also help to print function name that is problem in actual error (not only in note)
- test case for:
    io.printf("%.*s:%d:%d\n", #file.count, (#file).buf, #line, #column);
- tests/inputs/arr_append_gen_type.own: defer arr_free to free memory
- imporove ir printing
- make .own directory (or similar) for build artifacts and put .gitignore file in .own directory
- ** operator (pow)
- figure out how to handle redefinition of extern c functions
- make ir output more readable:
    -- label should be indented
    -- literal should be printed as literal instead of as just name
    -- have proper delimeters (eg. space)
- for below, figure out why order is wrong:
    tests/inputs/uninitialized.own:47:19:note:tracing path of uninitialized variable use
        46 |     switch way {
        47 |         case .way1: break
           |                   ^
        48 |         case .way2: status = 4
    tests/inputs/uninitialized.own:46:5:note:tracing path of uninitialized variable use
        45 |     let status i32
        46 |     switch way {
           |     ^
        47 |         case .way1: break
- proper print functions for Ulang_type_regular, etc.
- this can crash the compiler (because of the i32):
    io.printf("before 1: %d\n", *rt.static_array_access(nums, idx), "\n", i32)
- this operation should not return type f32:
    8.7 <= 7.7
- this operation should not be allowed (or should give warning):
    let lhs f32 = 8.6
    let rhs f32 = 8.4
    lhs == rhs
- assert statement to catch mod_path (other than MOD_PATH_BUILTIN) used for primitive types
- top level of file should actually have SCOPE_TOP_LEVEL?
    (for this to work, scope_iter function needs to consider mod path in addition to scope_id)
- "_1__7_builtin_str____2658" could be printed as "7builtin_str2658", 
    because variable names cannot start with digit anyway, and there is no need to encode pointer depth
- fix this parser bug:
    if curr < '0' || curr > '9' => break
    *str = slice_range(*str, 1, str.count - 1)
- ptr depth should be implemented using lang_type_ptr instead of storing ptr depth in atom?
    lang_type_ptr could have depth variable to reduce number of lang_type_ptrs needed
- TODO: size_t may not be the correct type
     for lang_type_array.count, because
     lang_type_array.count is not
     nessessarily based on memory size
     of computer that compilation happens
- check for return statement on all code paths
- possible optimizations to save memory:
    -- use bitsets
    -- save Pos as 48 or 64 bit var
    -- make size_t as 48 bit var?
    -- make Name be stored as pointer or offset in structs instead of by value?
    -- better arena management
    -- use views instead of vecs in ast and ir nodes?
    -- tokenizer could tokenize as parsing happens (with look ahead of about 3 tokens) instead of getting all tokens of file at once
- test case for int value being used as lang_type generic arg and vice versa
- if using "--no-prelude", and prelude functionality is still used anyway, the compiler should print
    proper error instead of crashing
- member_name of member access should not be substituted in generic substitution
- do_test.py should have confirmation before update
- check that the main function has the correct signature (make expected failure test)
- check that there are not duplicate main functions (make expected failure test)
- append own to all symbols when emitting c to prevent collisions with third party libraries, etc.
- in examples/calculator.own:13 ("for idx u64 in 0..amt_consumed => io.print_str(" ", "")"), I should
     be able to remove u64. fix bug that prevents it from being possible.
- figure out why this does not work:
    fn do_nothing(pretend_fn fn()) {
- remove Lang_type_atom and Ulang_type_atom
- set, get, and add pointer_depth functions should be auto generated for Lang_type and Ir_lang_type
- expected success case for nested struct literals used in generic arg

# roadmap to try to get bootstrap compiler done:
## needed features
- constraints in generics
- orelse, !!, ??, etc.
- extern("c") defintions
- printing features
- global constants
- global variables
- way to get tag of sum (be sure that checking if sums are equal is possible)
- mandatory initialization or similar
- manual zero initialization
- safe cast (use "cast(<i64>)" to cast num to i64)?
- test for break in switch case 
- distinct
- pointer generic
- warn about unused variables
- when using variadic args for extern("c") function: give error when passing i16 without a cast, etc.
- implement == for sum with void inner types, or give error for using ==
- test case for: let num f32 = 7
- binary operators with f64 literals on both sides (precomputation)
- consider renaming Llvm_store_another_llvm to Llvm_store
- consider renaming Llvm_load_another_llvm to Llvm_load
- expected failure case for:
    // Div is a struct
    let div Div = .num(9)
- expected failure case for invalid label at the end of the file:
    hello: i32
- expected failure test for:
continue(<thing>)
-tests for ir printing
- literal suffixes
- use DIAG_ERROR for things that must be an error?
- expected failure test for invalid type in unsafe_cast
- improve immediate representation dump so that it is actually readable
- make print functions check for null and print <null> or something instead of seg fault
- figure out if I should de-duplilcate string literals, etc.
- fix printing for lang_type in msg to not put newline
- expected failure case for invalid type in extern "c" function
- expected success test that excaped " is supported in string literal
- write documentation
- documentation should note that using can emulate inheritance in structs (I also need expected
    success test case for that)
- use libclang to get extern c definitions automatically




## needed tests
- let token* Token = <...>; switch token {<...>}

# optional things:
- const, etc.
- graphviz (for program control flow, etc.)
- foreach idea:
  fn foreach_tokens(tokens Token[]) {
      for idx in 0..tokens.count {
          for_yield tokens[idx]
      }
  }
- bit widths other than 1, 8, 16, 32, or 64 with the c backend
- when generics are mature, use them to associate custom allocators with things
- for testing: make overview grid that uses one letter per test to make it easier to see what tests pass
- windows support (including ci)
- support alternative backend


# in the far future
- try catch blocks with the question operator or similar
- dynamic dispatch in generics (function pointers, constant expressions, etc. should be stored in 
    table; there should be one table per generic variant)
- function to set break point in source code (eg. `breakpoint`)
- use own calling convention
    - types larger than 16 bytes should by passed by pointer?
