io :: import = std.io
util :: import = std.util


TokenType :: enum {
    number
    string
}

TokenType2 :: enum {
    number, string
}

Token :: struct {
    kind TokenType
    number_data i32
    string_data u8*
}

print_token_if :: fn(token Token) {
    if token.kind == TokenType.number {
        io.printf("%d\n", token.number_data)
    } else if token.kind == TokenType.string {
        io.printf("%s\n", token.string_data)
    } else {
        io.printf("invalid token type\n")
    }
}

print_token_switch :: fn(token Token) {
    switch token.kind {
    case TokenType.number: io.printf("%d\n", token.number_data)
    case TokenType.string: io.printf("%s\n", token.string_data)
    default: io.printf("invalid token type\n")
    }
}

print_token_switch_non_exhaustive :: fn(token Token) {
    switch token.kind {
    case TokenType.number: io.printf("%d\n", token.number_data)
    default: io.printf("invalid token type\n")
    }
}

// check that scope rules are followed for subtypes :: enum
NodeType :: enum {
    NONE
}

LlvmType :: enum {
    NONE
}

main :: fn() i32 {
    token_type TokenType := TokenType.number
    io.printf("%d\n", token_type);

    token_type = TokenType.string
    io.printf("%d\n", token_type);

    {
        token Token := {.number, 0, util.null(<u8>)()}
        token.kind = TokenType.number
        token.number_data = 87
        token.string_data = "hello"
        print_token_if(token)
        print_token_switch(token)
    }

    {
        token Token := {.number, 0, util.null(<u8>)()} 
        token.kind = TokenType.string
        token.number_data = 87
        token.string_data = "hello"
        print_token_if(token)
        print_token_switch(token)
    }

    {
        token Token := {.number, 0, util.null(<u8>)()}
        token.kind = TokenType.string
        token.number_data = 87
        token.string_data = "hello"
        print_token_switch_non_exhaustive(token)
    }
    return 0
}

