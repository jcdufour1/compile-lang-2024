rt :: import = std.runtime

printf :: extern("c") fn(format_string u8*, args opaque...) i32

do_thing :: fn(should_succeed u1) rt.Optional(<i32>) {
    if should_succeed => return .some(9)
    return .none
}

do_thing_with_err_val :: fn(should_succeed u1) rt.Result(<i32, i32>) {
    if should_succeed => return .ok(9)
    return .error(27)
}

FALSE :: def = 0
TRUE :: def = 1

Token :: struct {
    string u8*
}

thing1 :: fn() {
    num i32 := do_thing(FALSE) orelse {
        printf("yes1\n")
        return
    }
    printf("no1\n")
}

thing2 :: fn() {
    num i32 := do_thing(TRUE) orelse {
        printf("no2\n")
        return
    }
    printf("yes2\n")
    printf("%d\n", num)
}

thing3 :: fn() Token {
    num i32 := do_thing(FALSE) orelse {
        printf("yes3\n")
        return {"hello"}
    }
    printf("no3\n")
    return {"bye"}
}

thing4 :: fn() Token {
    num i32 := do_thing_with_err_val(FALSE) orelse(err) {
        printf("yes4: error is %d\n", err)
        return {"hello"}
    }
    printf("no4\n")
    return {"bye"}
}

thing5 :: fn() Token {
    num i32 := do_thing_with_err_val(TRUE) orelse(err) {
        printf("no5: error is %d\n", err)
        return {"hello"}
    }
    printf("yes5\n")
    printf("%d\n", num)
    return {"bye"}
}

main :: fn() i32 {
    thing1()
    thing2()
    printf("%s\n", thing3().string)
    thing4()
    thing5()

    return 0
}
