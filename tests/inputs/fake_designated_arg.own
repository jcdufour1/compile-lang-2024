type coll import = std.collections

// these local functions and Local_arr are needed in case the std functions get modified
//   (so that this test will still catch the bug that it was designed to catch)

type Local_arr struct(<ItemT>) {
    buf ItemT*
    count u64
    max u64
}

fn arr_new(max_capacity u64, ItemT Type, init_elems coll.Slice(<ItemT>) = [], file coll.Str = #file, line i32 = #line, column i32 = #column) Local_arr(<ItemT>) {
    let arr Local_arr(<ItemT>) = {util.alloc(max_capacity, ItemT), 0, max_capacity}
    arr_extend(&arr, init_elems, .file = file, .line = line, .column = column)
    return arr
}

fn arr_extend(dest coll.Local_arr(<ItemT>)*, src coll.Slice(<ItemT>), ItemT Type, file Str = #file, line i32 = #line, column i32 = #column) {
    for idx u64 in 0..src.count {
        arr_append(dest, slice_at(src, idx), .file = file, .line = line, .column = column)
    }
}

fn main() i32 {
    let arr Local_arr(<i32>) = arr_new(87, i32)
    arr_extend(&arr, [], .file = file, column = 8)
    return 0
}
