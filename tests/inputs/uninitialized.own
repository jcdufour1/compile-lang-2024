Way :: enum {
    way1
    way2
}

Token :: struct {
    num i32
    character u8
}

aux_1arg :: fn(arg i32) i32 {
    num i32 := arg
    return arg
}

wrong1 :: fn() i32 {
    status i32 :
    return status
}

wrong2 :: fn() i32 {
    status i32 :
    aux_1arg(status)
    status = 8
    return status
}

right1 :: fn() i32 {
    status i32 :
    if 1 {
        status = 1
    } else {
        status = 4
    }
    return status
}

wrong3 :: fn() i32 {
    status i32 :
    if 1 {
    } else {
        status = 4
    }
    return status
}

// TODO: uncomment and check that this function generates uninitalized error
wrong4 :: fn() i32 {
    way Way := .way1
    status i32 :
    switch way {
        case .way1: break
        case .way2: status = 4
    }
    return status
}

wrong5 :: fn() i32 {
    token Token :
    return token.num
}

// num var in wrong6 must have the same name as num member in Token struct to test that they do not collide
wrong6 :: fn() i32 {
    {
        num i32 := 0
    }

    {
        num i32 :
        num2 i32 := num
    }

    return 0
}

wrong7 :: fn() i32 {
    num i32 :

    for 1 {
        num2 i32 := num
    }

    return 0
}

wrong8 :: fn() i32 {
    status i32 :
    return status
}

main :: fn() i32 {
    wrong1()
    wrong2()
    wrong3()
    wrong4() // TODO: uncomment wrong4() and check that this function generates uninitalized error
    wrong5()
    wrong6()
    wrong7()
    wrong8()
    right1()
    right2()
    return 0
}

right2 :: fn() {
    num i32 : @maybe_uninit
    num2 := num
}
