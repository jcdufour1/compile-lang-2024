compile::stdout 0

compile::stderr 30
tests/inputs/question_mark_operator_sema_errors.own:19:16:[1;31merror[0;39m:type `i32` cannot be implicitly converted to `u8`
    18 | fn thing1() {
    19 |     let num u8 = do_thing(TRUE)?
       |                ^
    20 |     printf("num = %d\n", num)
tests/inputs/question_mark_operator_sema_errors.own:24:32:[1;31merror[0;39m:ErrorT of `?` left hand side is of type `i64`, but ErrorT of the function return type is of type `u8` (`i64` cannot be assigned to `u8`)
    23 | fn thing2() rt.Result(<i32, u8>) {
    24 |     do_thing_with_err_val(TRUE)?
       |                                ^
    25 |     return .ok(8)
tests/inputs/question_mark_operator_sema_errors.own:10:61:[1;34mnote[0;39m:ErrorT of left hand side defined here
     9 | 
    10 | fn do_thing_with_err_val(should_succeed u1) rt.Result(<i32, i64>) {
       |                                                             ^
    11 |     if should_succeed => return .ok(9)
tests/inputs/question_mark_operator_sema_errors.own:23:29:[1;34mnote[0;39m:ErrorT of function return type defined here
    22 | 
    23 | fn thing2() rt.Result(<i32, u8>) {
       |                             ^
    24 |     do_thing_with_err_val(TRUE)?
tests/inputs/question_mark_operator_sema_errors.own:29:5:[1;31merror[0;39m:expected result type on left hand side of `?`, but got type `Optional(<i32>)`
    28 | fn thing3() rt.Result(<i32, u8>) {
    29 |     do_thing(TRUE)?
       |     ^
    30 |     return .ok(8)
tests/inputs/question_mark_operator_sema_errors.own:28:16:[1;34mnote[0;39m:result type is required for the left hand side of `?` because the function return type is a result type
    27 | 
    28 | fn thing3() rt.Result(<i32, u8>) {
       |                ^
    29 |     do_thing(TRUE)?

compile::return_code 1

