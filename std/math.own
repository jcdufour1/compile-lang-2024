type util import = std.util

fn abs(num NumT, NumT Type) NumT {
    if num < unsafe_cast<NumT>0 {
        // TODO: "-num" should be allowed for floating point types
        return unsafe_cast<NumT>0 - num
    }
    return num
}

fn pow(base BaseT, exponent ExpT, BaseT Type, ExpT Type) BaseT {
    let result BaseT = unsafe_cast<BaseT>1
    for idx ExpT in 0..exponent {
        result *= base
    }
    return result
}

// TODO: this function is intended for floating point numbers. Figure out what to do for integers?
fn sqrt(num NumT, NumT Type) NumT {
    if sizeof(num) <= 4 {
        return unsafe_cast<NumT>util.sqrtf(unsafe_cast<f32>num)
    }
    if sizeof(num) <= 8 {
        return unsafe_cast<NumT>util.sqrt(unsafe_cast<f64>num)
    }
    // TODO: use sqrtl for 128f?
    util.assert(0, "sqrt for numbers larger than f64 is not yet implemented")
    return unsafe_cast<NumT>0
}
