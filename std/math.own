type util import = std.util
type c import = std.libc

fn abs(num NumT, NumT Type) NumT {
    if num < unsafe_cast<NumT>0 {
        // TODO: "-num" should be allowed for floating point types
        return unsafe_cast<NumT>0 - num
    }
    return num
}

fn pow(base BaseT, exponent ExpT, BaseT Type, ExpT Type) BaseT {
    let result BaseT = unsafe_cast<BaseT>1
    for idx ExpT in 0..exponent {
        result *= base
    }
    return result
}

// TODO: this function is intended primarily for floating point numbers. Figure out what to do for integers?
fn sqrt(num NumT, NumT Type) NumT {
    // TODO: consider edge cases such as negative numbers?
    if sizeof(num) <= 4 {
        return unsafe_cast<NumT>c.sqrtf(unsafe_cast<f32>num)
    }
    if sizeof(num) <= 8 {
        return unsafe_cast<NumT>c.sqrt(unsafe_cast<f64>num)
    }
    // TODO: use sqrtl for 128f?
    util.assert(0, "sqrt for numbers larger than f64 is not yet implemented")
    return unsafe_cast<NumT>0
}

// TODO: this function is intended primarily for floating point numbers. Figure out what to do for integers?
fn log(num NumT, NumT Type) NumT {
    // TODO: consider edge cases such as negative numbers?
    if sizeof(num) <= 4 {
        return unsafe_cast<NumT>c.logf(unsafe_cast<f32>num)
    }
    if sizeof(num) <= 8 {
        return unsafe_cast<NumT>c.log(unsafe_cast<f64>num)
    }
    // TODO: use sqrtl for 128f?
    util.assert(0, "log for numbers larger than f64 is not yet implemented")
    return unsafe_cast<NumT>0
}

fn pi(NumT Type) NumT {
    util.assert(sizeof(NumT) <= 16, "pi for type larger than f128 not implemented");
    return unsafe_cast<NumT>3.14159265358979323846264338327950288419716939937510
}

fn e(NumT Type) NumT {
    util.assert(sizeof(NumT) <= 16, "e for type larger than f128 not implemented");
    return 2.7182818284590452353602874713526624977572
}
