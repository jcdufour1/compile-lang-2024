type util import = std.util
type c import = std.libc

fn min(<NumT>)(lhs NumT, rhs NumT) NumT {
    if lhs < rhs => return lhs
    return rhs
}

fn max(<NumT>)(lhs NumT, rhs NumT) NumT {
    if lhs > rhs => return lhs
    return rhs
}

fn abs(<NumT>)(num NumT) NumT {
    if num < unsafe_cast<NumT>0 {
        // TODO: "-num" should be allowed for floating point types
        return unsafe_cast<NumT>0 - num
    }
    return num
}

fn pow(<BaseT, ExpT>)(base BaseT, exponent ExpT) BaseT {
    let result BaseT = unsafe_cast<BaseT>1
    for idx ExpT in 0..exponent {
        result *= base
    }
    return result
}

// TODO: this function is intended primarily for floating point numbers. Figure out what to do for integers?
fn sqrt(<NumT>)(num NumT) NumT {
    // TODO: consider edge cases such as negative numbers?
    if sizeof(num) <= 4 {
        return unsafe_cast<NumT>c.sqrtf(unsafe_cast<f32>num)
    }
    if sizeof(num) <= 8 {
        return unsafe_cast<NumT>c.sqrt(unsafe_cast<f64>num)
    }
    // TODO: use sqrtl for 128f?
    util.assert(0, "sqrt for numbers larger than f64 is not yet implemented")
    return unsafe_cast<NumT>0
}

// TODO: this function is intended primarily for floating point numbers. Figure out what to do for integers?
fn log(<NumT>)(num NumT) NumT {
    // TODO: consider edge cases such as negative numbers?
    if sizeof(num) <= 4 {
        return unsafe_cast<NumT>c.logf(unsafe_cast<f32>num)
    }
    if sizeof(num) <= 8 {
        return unsafe_cast<NumT>c.log(unsafe_cast<f64>num)
    }
    // TODO: use sqrtl for 128f?
    util.assert(0, "log for numbers larger than f64 is not yet implemented")
    return unsafe_cast<NumT>0
}

fn pi(<NumT>)() NumT {
    util.assert(sizeof(NumT) <= 16, "pi for type larger than f128 not implemented");
    return unsafe_cast<NumT>3.14159265358979323846264338327950288419716939937510
}

fn e(<NumT>)() NumT {
    util.assert(sizeof(NumT) <= 16, "e for type larger than f128 not implemented");
    return unsafe_cast<NumT>2.7182818284590452353602874713526624977572
}
