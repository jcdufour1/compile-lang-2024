
util :: import = std.util
io :: import = std.io
rt :: import = std.runtime

Slice :: def rt.Slice
Str :: def u8[]

// TODO: make alloc function instead of using malloc directly

slice_range :: fn(<ItemT>)(slice ItemT[], start usize, count usize, file Str = #file, line i32 = #line, column i32 = #column) ItemT[] {
    if count < 1 {
        return {util.null(<ItemT>)(), 0}
    }
    assert(start < slice.count && start + count <= slice.count, "out of bounds", .file = file, .line = line, .column = column);
    return {&rt.buf_at(slice.buf, start), count}
}

slice_at :: fn(<ItemT>)(slice ItemT[], index usize, file Str = #file, line i32 = #line, column i32 = #column) ItemT {
    return *slice_at_ref(slice, index, file, line, column)
}

slice_at_ref :: def rt.slice_at_ref 

slice_consume :: fn(<ItemT>)(slice ItemT[]*, to_consume ItemT, file Str = #file, line i32 = #line, column i32 = #column) ItemT? {
    if slice.count < 1 => return .none
    if slice[0] != to_consume => return .none

    defer *slice = slice_range(*slice, 1, slice.count - 1)
    return .some(slice[0])
}

slice_try_get :: fn(<ItemT>)(slice ItemT[]*, should_get fn(ItemT) u1, file Str = #file, line i32 = #line, column i32 = #column) ItemT? {
    if slice.count < 1 => return .none
    if !should_get(slice[0]) => return .none

    defer *slice = slice_range(*slice, 1, slice.count - 1)
    return .some(slice[0])
}

slice_starts_with :: fn(<ItemT>)(slice ItemT[], start ItemT[], file Str = #file, line i32 = #line, column i32 = #column) u1 {
    if slice.count < start.count => return 0
    for idx in 0..start.count {
        if slice[idx] != start[idx] => return 0
    }
    return 1
}

slice_reverse_in_place :: fn(<ItemT>)(slice ItemT[]) {
    for idx in 0..slice.count/2 {
        util.swap(&slice[idx], &slice[slice.count - 1 - idx])
    }
}

// TODO: count and max should be usize by default when usize is implemented
// TODO: make max compile time when possible
Arr :: struct(<ItemT, capacity ''usize>) {
    buf ItemT*
    count usize
}

arr_new :: fn(<ItemT, max_capacity ''usize>)(init_elems ItemT[] = [], file Str = #file, line i32 = #line, column i32 = #column) Arr(<ItemT, max_capacity>) {
    arr Arr(<ItemT, max_capacity>) := {util.alloc(<ItemT>)(max_capacity), 0}
    arr_extend(&arr, init_elems, .file = file, .line = line, .column = column)
    return arr
}

arr_slice :: fn(<ItemT, max_capacity ''usize>)(arr Arr(<ItemT, max_capacity>), start usize = 0, count usize? = .none, file Str = #file, line i32 = #line, column i32 = #column) ItemT[] {
    actual_count usize := arr.count - start
    if .some(num) := count {
        actual_count = num
    }
    slice ItemT[] := {arr.buf, arr.count}
    return slice_range(slice, start, actual_count, .file = file, .line = line, .column = column)
    //// TODO: uncomment below line (figure out why it will not compile)
    ////return slice_range({arr.buf, arr.count}, start, actual_count)
}

arr_free :: fn(<ItemT, max_capacity ''usize>)(arr Arr(<ItemT, max_capacity>)*) {
    util.free(arr.buf);
    arr.buf = util.null(<ItemT>)() 
    arr.count = 0
}

arr_insert :: fn(<ItemT, max_capacity ''usize>)(arr Arr(<ItemT, max_capacity>)*, item ItemT, index usize, file Str = #file, line i32 = #line, column i32 = #column) {
    assert(arr.count < arr.capacity, "Arr overflow", .file = file, .line = line, .column = column);
    assert(index <= arr.count, "out of bounds", .file = file, .line = line, .column = column);
    if (arr.count - index > 0) {
        util.move_items(&rt.buf_at(arr.buf, index + 1), &rt.buf_at(arr.buf, index), arr.count - index);
    }
    rt.buf_at(arr.buf, index) = item
    arr.count += 1
}

arr_append :: fn(<ItemT, max_capacity ''usize>)(arr Arr(<ItemT, max_capacity>)*, item ItemT, file Str = #file, line i32 = #line, column i32 = #column) {
    assert(arr.count < arr.capacity, "Arr overflow", .file = file, .line = line, .column = column);
    rt.buf_at(arr.buf, arr.count) = item
    arr.count += 1
}

arr_extend :: fn(<ItemT, max_capacity ''usize>)(dest Arr(<ItemT, max_capacity>)*, src ItemT[], file Str = #file, line i32 = #line, column i32 = #column) {
    for idx in 0..src.count {
        arr_append(dest, src[idx], .file = file, .line = line, .column = column)
    }
}

arr_remove :: fn(<ItemT, max_capacity ''usize>)(arr Arr(<ItemT, max_capacity>)*, index usize, file Str = #file, line i32 = #line, column i32 = #column) {
    assert(arr.count > 0, "attempt to remove element from empty array", .file = file, .line = line, .column = column);
    assert(index < arr.count, "out of bounds", .file = file, .line = line, .column = column);
    arr.count -= 1
    if (arr.count - index > 0) {
        util.move_items(&rt.buf_at(arr.buf, index), &rt.buf_at(arr.buf, index + 1), arr.count - index);
    }
}

arr_at :: fn(<ItemT, max_capacity ''usize>)(arr Arr(<ItemT, max_capacity>), index usize, file Str = #file, line i32 = #line, column i32 = #column) ItemT {
    assert(index < arr.count, "out of bounds", .file = file, .line = line, .column = column);
    return rt.buf_at(arr.buf, index)
}

arr_at_ref :: fn(<ItemT, max_capacity ''usize>)(arr Arr(<ItemT, max_capacity>), index usize, file Str = #file, line i32 = #line, column i32 = #column) ItemT* {
    util.assert(index < arr.count, "out of bounds", .file = file, .line = line, .column = column);
    return &rt.buf_at(arr.buf, index)
}

arr_first :: fn(<ItemT, max_capacity ''usize>)(arr Arr(<ItemT, max_capacity>), file Str = #file, line i32 = #line, column i32 = #column) ItemT {
    return arr_at(arr, 0, .file = file, .line = line, .column = column)
}

arr_last :: fn(<ItemT, max_capacity ''usize>)(arr Arr(<ItemT, max_capacity>), file Str = #file, line i32 = #line, column i32 = #column) ItemT {
    assert(index < arr.count, "out of bounds", .file = file, .line = line, .column = column);
    return arr.buf[arr.count - 1]
}

Darr :: struct(<ItemT>) {
    buf ItemT*
    count usize
    capacity usize
}

darr_new :: fn(<ItemT>)(init_elems ItemT[] = [], file Str = #file, line i32 = #line, column i32 = #column) Darr(<ItemT>) {
    darr Darr(<ItemT>) := {util.null(<ItemT>)(), 0, 0}
    darr_extend(&darr, init_elems, .file = file, .line = line, .column = column)
    return darr
}

darr_slice :: fn(<ItemT>)(darr Darr(<ItemT>), start usize = 0, count usize? = .none, file Str = #file, line i32 = #line, column i32 = #column) ItemT[] {
    actual_count usize := darr.count - start
    if .some(num) := count {
        actual_count = num
    }
    slice ItemT[] := {darr.buf, darr.count}
    return slice_range(slice, start, actual_count, .file = file, .line = line, .column = column)
    // TODO: uncomment below line (figure out why it will not compile)
    //return slice_range({darr.buf, darr.count}, start, actual_count)
}

darr_free :: fn(<ItemT>)(using darr Darr(<ItemT>)*) {
    util.free(buf);
    buf = util.null(<ItemT>)()
    count = 0
    capacity = 0
}

// TODO: pass line, etc. in here or return optional instead of failing for out of memory
darr_reserve :: fn(<ItemT>)(darr Darr(<ItemT>)*, count_items_to_add usize) {
    if darr.count + count_items_to_add > darr.capacity {
        if darr.capacity < 1 {
            darr.capacity = 1 // TODO: initial capacity should probably be higher than 1?
            for darr.count + count_items_to_add > darr.capacity {
                darr.capacity *= 2
            }
            darr.buf = util.alloc(<ItemT>)(darr.capacity)
        } else {
            for darr.count + count_items_to_add > darr.capacity {
                darr.capacity *= 2
            }
            darr.buf = util.realloc(darr.buf, darr.capacity)
        }
    }
}

darr_insert :: fn(<ItemT>)(darr Darr(<ItemT>)*, item ItemT, index usize, file Str = #file, line i32 = #line, column i32 = #column) {
    darr_reserve(darr, 1);
    assert(index <= darr.count, "out of bounds", .file = file, .line = line, .column = column);
    if (darr.count - index > 0) {
        util.move_items(&rt.buf_at(darr.buf, index + 1), &rt.buf_at(darr.buf, index), darr.count - index);
    }
    rt.buf_at(darr.buf, index) = item
    darr.count += 1
}

darr_append :: fn(<ItemT>)(darr Darr(<ItemT>)*, item ItemT, file Str = #file, line i32 = #line, column i32 = #column) {
    darr_reserve(darr, 1);
    rt.buf_at(darr.buf, darr.count) = item
    darr.count += 1
}

darr_extend :: fn(<ItemT>)(dest Darr(<ItemT>)*, src ItemT[], file Str = #file, line i32 = #line, column i32 = #column) {
    for idx in 0..src.count {
        darr_append(dest, src[idx], .file = file, .line = line, .column = column)
    }
}

darr_remove :: fn(<ItemT>)(darr Darr(<ItemT>)*, index usize, file Str = #file, line i32 = #line, column i32 = #column) ItemT {
    assert(darr.count > 0, "attempt to remove element from empty dynamic array", .file = file, .line = line, .column = column);
    assert(index < darr.count, "out of bounds", .file = file, .line = line, .column = column);
    darr.count -= 1
    if (darr.count - index > 0) {
        util.move_items(&rt.buf_at(darr.buf, index), &rt.buf_at(darr.buf, index + 1), darr.count - index);
    }
    return rt.buf_at(darr.buf, index)
}

darr_pop :: fn(<ItemT>)(darr Darr(<ItemT>)*, file Str = #file, line i32 = #line, column i32 = #column) ItemT {
    assert(darr.count > 0, "attempt to remove element from empty dynamic array", .file = file, .line = line, .column = column);
    return darr_remove(darr, darr.count - 1, .file = file, .line = line, .column = column)
}

darr_at_ref :: fn(<ItemT>)(darr Darr(<ItemT>), index usize, file Str = #file, line i32 = #line, column i32 = #column) ItemT* {
    assert(index < darr.count, "out of bounds", .file = file, .line = line, .column = column);
    return &rt.buf_at(darr.buf, index)
}

darr_at :: fn(<ItemT>)(darr Darr(<ItemT>), index usize, file Str = #file, line i32 = #line, column i32 = #column) ItemT {
    return *darr_at_ref(darr, index, .file = file, .line = line, .column = column)
}

darr_first :: fn(<ItemT>)(darr Darr(<ItemT>), file Str = #file, line i32 = #line, column i32 = #column) ItemT {
    return darr_at(darr, 0, .file = file, .line = line, .column = column)
}

darr_last :: fn(<ItemT>)(darr Darr(<ItemT>), file Str = #file, line i32 = #line, column i32 = #column) ItemT {
    assert(index < darr.count, "out of bounds", .file = file, .line = line, .column = column);
    return rt.buf_at(darr.buf, darr.count - 1)
}

// TODO: return result, optional, etc. instead of crashing?
// TODO: check for overflow
// TODO: call str_consume_int function to reduce duplication
str_to_int :: fn(<NumT>)(str Str, file Str = #file, line i32 = #line, column i32 = #column) NumT {
    should_neg u1 := 0
    if slice_at(str, 0, .file = file, .line = line, .column = column) == '-' {
        should_neg = 1
        str = slice_range(str, 1, str.count - 1)
    }

    result NumT := 0
    for idx in 0..str.count {
        result *= 10

        curr u8 := slice_at(str, idx, .file = file, .line = line, .column = column)
        assert(
            curr >= '0' && curr <= '9',
            "str contains nonzero digits",
            .file = file,
            .line = line,
            .column = column
        )
        result += unsafe_cast<u8>curr - '0'
    }

    if should_neg {
        result *= -1
    }

    return result
}

// TODO: check for overflow
str_consume_int :: fn(<NumT>)(str Str*, file Str = #file, line i32 = #line, column i32 = #column) NumT? {
    should_neg u1 := 0
    if slice_at(*str, 0, .file = file, .line = line, .column = column) == '-' {
        should_neg = 1
        *str = slice_range(*str, 1, str.count - 1)
    }

    result NumT := 0
    is_some u1 := 0
    for str.count > 0 {
        curr NumT := unsafe_cast<NumT>str[0]
        //curr NumT := unsafe_cast<NumT>str[0]
        if curr < '0' || curr > '9' => break

        is_some = 1
        *str = slice_range(*str, 1, str.count - 1)
        result *= 10
        result += curr - '0'
    }

    if !is_some => return .none

    if should_neg => result *= -1
    return .some(result)
}

// TODO: return result, optional, etc. instead of crashing?
str_from_int :: fn(<NumT>)(num NumT, file Str = #file, line i32 = #line, column i32 = #column) Darr(<u8>) {
    result Darr(<u8>) := darr_new(<u8>)()
    if num == 0 {
        darr_append(&result, '0')
        return result
    }

    should_neg u1 := 0
    if num < 0 {
        should_neg = 1
        num *= unsafe_cast<NumT>-1
    }

    for num > 0 {
        darr_append(&result, '0' + unsafe_cast<u8>(num%10))
        num /= 10
    }
    if should_neg {
        darr_append(&result, '-')
    }

    slice_reverse_in_place(darr_slice(result))
    return result
}

