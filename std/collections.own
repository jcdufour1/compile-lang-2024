
type util import = std.util
type io import = std.io

// TODO: consider making Slice.count type generic (probably implement default arguments for generics first)
// TODO: count should be usize by default when usize is implemented
type Slice struct(<ItemT>) {
    buf ItemT*
    count u64
}

fn slice_at(slice Slice(<ItemT>), index u64, ItemT Type) ItemT {
    if (index >= slice.count) {
        util.abort()
    }
    return slice.buf[index]
}

// TODO: count and max should be usize by default when usize is implemented
type Arr struct(<ItemT>) {
    buf ItemT*
    count u64
    max u64
}

fn arr_new(max_capacity u64, ItemT Type, init_elems Slice(<ItemT>) = [], file u8* = #file, line i32 = #line, column i32 = #column) Arr(<ItemT>) {
    let buf ItemT* = unsafe_cast<ItemT*>util.malloc(sizeof(ItemT)*max_capacity)
    util.assert(buf != unsafe_cast<ItemT*>0, "out of memory", .file = file, .line = line, .column = column)
    let arr Arr(<ItemT>) = {buf, 0, max_capacity}
    arr_extend(&arr, init_elems, .file = file, .line = line, .column = column)
    return arr
}

fn arr_free(arr Arr(<ItemT>)*, ItemT Type) {
    util.free(unsafe_cast<opaque*>arr.buf);
    arr.buf = unsafe_cast<ItemT*>0
    arr.max = 0
    arr.count = 0
}

fn arr_insert(arr Arr(<ItemT>)*, item ItemT, index u64, ItemT Type, file u8* = #file, line i32 = #line, column i32 = #column) {
    util.assert(arr.count < arr.max, "Arr overflow", .file = file, .line = line, .column = column);
    util.assert(index <= arr.count, "out of bounds", .file = file, .line = line, .column = column);
    if (arr.count - index > 0) {
        // TODO: fix type inference bug, then remove explicit ItemT arguent here
        util.move_items(&arr.buf[index + 1], &arr.buf[index], arr.count - index, ItemT);
    }
    arr.buf[index] = item
    arr.count += 1
}

fn arr_append(arr Arr(<ItemT>)*, item ItemT, ItemT Type, file u8* = #file, line i32 = #line, column i32 = #column) {
    util.assert(arr.count < arr.max, "Arr overflow", .file = file, .line = line, .column = column);
    arr.buf[arr.count] = item
    arr.count += 1
}

fn arr_extend(dest Arr(<ItemT>)*, src Slice(<ItemT>), ItemT Type, file u8* = #file, line i32 = #line, column i32 = #column) {
    for idx u64 in 0..src.count {
        arr_append(dest, slice_at(src, idx), .file = file, .line = line, .column = column)
    }
}

fn arr_remove(arr Arr(<ItemT>)*, index u64, ItemT Type, file u8* = #file, line i32 = #line, column i32 = #column) {
    util.assert(arr.count > 0, "attempt to remove element from empty array", .file = file, .line = line, .column = column);
    util.assert(index < arr.count, "out of bounds", .file = file, .line = line, .column = column);
    arr.count -= 1
    if (arr.count - index > 0) {
        // TODO: fix type inference bug, then remove explicit ItemT arguent here
        util.move_items(&arr.buf[index], &arr.buf[index + 1], arr.count - index, ItemT);
    }
}

fn arr_at(arr Arr(<ItemT>), index u64, ItemT Type, file u8* = #file, line i32 = #line, column i32 = #column) ItemT {
    util.assert(index < arr.count, "out of bounds", .file = file, .line = line, .column = column);
    return arr.buf[index]
}

fn arr_first(arr Arr(<ItemT>), ItemT Type, file u8* = #file, line i32 = #line, column i32 = #column) ItemT {
    return arr_at(arr, 0, .file = file, .line = line, .column = column)
}

fn arr_last(arr Arr(<ItemT>), ItemT Type, file u8* = #file, line i32 = #line, column i32 = #column) ItemT {
    util.assert(index < arr.count, "out of bounds", .file = file, .line = line, .column = column);
    return arr.buf[arr.count - 1]
}

type Darr struct(<ItemT>) {
    buf ItemT*
    count u64
    capacity u64
}

fn darr_new(ItemT Type, init_elems Slice(<ItemT>) = [], file u8* = #file, line i32 = #line, column i32 = #column) Darr(<ItemT>) {
    let darr Darr(<ItemT>) = {unsafe_cast<ItemT*>0, 0, 0}
    darr_extend(&darr, init_elems, .file = file, .line = line, .column = column)
    return darr
}

fn darr_free(darr Darr(<ItemT>)*, ItemT Type) {
    util.free(unsafe_cast<opaque*>darr.buf);
    darr.buf = unsafe_cast<ItemT*>0
    darr.count = 0
    darr.capacity = 0
}

fn darr_reserve(darr Darr(<ItemT>)*, count_items_to_add u64, ItemT Type) {
    if darr.count + count_items_to_add > darr.capacity {
        if darr.capacity < 1 {
            darr.capacity = 1 // TODO: initial capacity should probably be higher than 1?
            for darr.count + count_items_to_add > darr.capacity {
                darr.capacity *= 2
            }
            darr.buf = unsafe_cast<ItemT*>util.malloc(sizeof(ItemT)*darr.capacity)
        } else {
            for darr.count + count_items_to_add > darr.capacity {
                darr.capacity *= 2
            }
            darr.buf = unsafe_cast<ItemT*>util.realloc(unsafe_cast<opaque*>darr.buf, sizeof(ItemT)*darr.capacity)
        }
    }
}

fn darr_insert(darr Darr(<ItemT>)*, item ItemT, index u64, ItemT Type, file u8* = #file, line i32 = #line, column i32 = #column) {
    darr_reserve(darr, 1);
    util.assert(index <= darr.count, "out of bounds", .file = file, .line = line, .column = column);
    if (darr.count - index > 0) {
        // TODO: fix type inference bug, then remove explicit ItemT arguent here
        util.move_items(&darr.buf[index + 1], &darr.buf[index], darr.count - index, ItemT);
    }
    darr.buf[index] = item
    darr.count += 1
}

fn darr_append(darr Darr(<ItemT>)*, item ItemT, ItemT Type, file u8* = #file, line i32 = #line, column i32 = #column) {
    darr_reserve(darr, 1);
    darr.buf[darr.count] = item
    darr.count += 1
}

fn darr_extend(dest Darr(<ItemT>)*, src Slice(<ItemT>), ItemT Type, file u8* = #file, line i32 = #line, column i32 = #column) {
    for idx u64 in 0..src.count {
        darr_append(dest, slice_at(src, idx), .file = file, .line = line, .column = column)
    }
}

// TODO: return item removed?
fn darr_remove(darr Darr(<ItemT>)*, index u64, ItemT Type, file u8* = #file, line i32 = #line, column i32 = #column) {
    util.assert(darr.count > 0, "attempt to remove element from empty dynamic array", .file = file, .line = line, .column = column);
    util.assert(index < darr.count, "out of bounds", .file = file, .line = line, .column = column);
    darr.count -= 1
    if (darr.count - index > 0) {
        // TODO: fix type inference bug, then remove explicit ItemT arguent here
        util.move_items(&darr.buf[index], &darr.buf[index + 1], darr.count - index, ItemT);
    }
}

fn darr_at(darr Darr(<ItemT>), index u64, ItemT Type, file u8* = #file, line i32 = #line, column i32 = #column) ItemT {
    util.assert(index < darr.count, "out of bounds", .file = file, .line = line, .column = column);
    return darr.buf[index]
}

fn darr_first(darr Darr(<ItemT>), ItemT Type, file u8* = #file, line i32 = #line, column i32 = #column) ItemT {
    return darr_at(darr, 0, .file = file, .line = line, .column = column)
}

fn darr_last(darr Darr(<ItemT>), ItemT Type, file u8* = #file, line i32 = #line, column i32 = #column) ItemT {
    util.assert(index < darr.count, "out of bounds", .file = file, .line = line, .column = column);
    return darr.buf[darr.count - 1]
}
