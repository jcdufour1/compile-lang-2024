type io import = std.io
type rt import = std.runtime

extern("c") fn isdigit(character i32) i32
extern("c") fn abort()
extern("c") fn malloc(size u64) opaque*
extern("c") fn realloc(ptr opaque*, size u64) opaque*
extern("c") fn free(ptr opaque*)
extern("c") fn memmove(dest opaque*, src opaque*, n u64)
extern("c") fn sqrtf(num f32) f32
extern("c") fn sqrt(num f64) f64
extern("c") fn logf(num f32) f32
extern("c") fn log(num f64) f64
extern("c") fn strlen(cstr u8*) u64

type Optional enum(<ItemT>) {
    some ItemT
    none
}

// overlapping regions are allowed
// count_items is the number of items to move, not the number of bytes
fn move_items(dest ItemT*, src ItemT*, count_items u64, ItemT Type) {
    memmove(unsafe_cast<opaque*>dest, unsafe_cast<opaque*>src, sizeof(ItemT)*count_items);
}

// TODO: remove keep_going parameter from std?
fn assert(condition u1, message u8* = "", keep_going u1 = 0, file u8* = #file, line i32 = #line, column i32 = #column) {
    if (!condition) {
        // TODO: print to stderr
        io.printf("%s:%d:%d:assertion failure: %s\n", file, line, column, message)
        if (!keep_going) {
            abort()
        }
    }
}

fn slice_from_cstr(cstr u8*) rt.Slice(<u8>) {
    return {cstr, strlen(cstr)}
}
