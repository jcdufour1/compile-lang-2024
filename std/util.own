io :: import = std.io
rt :: import = std.runtime
libc :: import = std.libc
coll :: import = std.collections

Optional :: def = rt.Optional
Result :: def = rt.Result

usize :: def = rt.usize
//ptr :: def = opaque*

// overlapping regions are allowed
// count_items is the number of items to move, not the number of bytes
move_items :: fn(<ItemT>)(dest ItemT*, src ItemT*, count_items u64) {
    libc.memmove(unsafe_cast<opaque*>dest, unsafe_cast<opaque*>src, sizeof(*dest)*count_items);
}

// TODO: (return ItemT instead of ItemT*)? (because ptr could be used as alias for opaque* in the future)
null :: fn(<ItemT>)() ItemT* {
    return unsafe_cast<ItemT*>0
}

bitcast :: fn(<CastTo, From>)(item From) CastTo {
    return *unsafe_cast<CastTo*>&item
}

swap :: fn(<ItemT>)(lhs ItemT*, rhs ItemT*) {
    temp ItemT := *lhs
    *lhs = *rhs
    *rhs = temp
}

// TODO: return optional, etc.?
alloc :: fn(<ItemT>)(count_items u64, file Str = #file, line i32 = #line, column i32 = #column) ItemT* {
    dummy ItemT* := null(<ItemT>)();
    buf ItemT* := unsafe_cast<ItemT*>libc.malloc(sizeof(*dummy)*count_items)
    assert(buf != null(<ItemT>)(), "out of memory", .file = file, .line = line, .column = column)
    return buf
}

// TODO: return optional, etc.?
realloc :: fn(<ItemT>)(buf ItemT*, new_cnt_items u64, file Str = #file, line i32 = #line, column i32 = #column) ItemT* {
    buf = unsafe_cast<ItemT*>libc.realloc(unsafe_cast<opaque*>buf, sizeof(ItemT)*new_cnt_items)
    assert(buf != null(<ItemT>)(), "out of memory", .file = file, .line = line, .column = column)
    return buf
}

free :: fn(<ItemT>)(buf ItemT*) {
    libc.free(unsafe_cast<opaque*>buf)
}

assert :: def = rt.assert

// NOTE: cstr_free should be called on the returned string later
str_to_cstr :: fn(str coll.Str) u8* {
    cstr coll.Darr(<u8>) := coll.darr_new(<u8>)(str)
    coll.darr_append(&cstr, '\0')
    return cstr.buf
}

cstr_free :: fn(cstr u8*) {
    libc.free(unsafe_cast<opaque*>cstr)
}

slice_from_cstr :: fn(cstr u8*) Str {
    return {cstr, strlen(cstr)}
}

zero :: fn(<ItemT>)() ItemT {
    assert(0, "todo")
    //item ItemT @maybe_uninit
    //libc.memset(unsafe_cast<opaque*>&item, 0, sizeof(item))
    //return item
}
