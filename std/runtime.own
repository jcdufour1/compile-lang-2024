// TODO: consider making Slice.count type generic (probably implement default arguments for generics first)
// TODO: count should be usize by default when usize is implemented

Slice :: struct(<ItemT>) {
    buf ItemT*
    count usize
}

Optional :: enum(<ItemT>) {
    some ItemT
    none
}

Result :: enum(<OkT, ErrorT>) {
    ok OkT
    error ErrorT
}

File :: struct {
    file opaque*
}

// TODO: move assert function to runtime?
fn slice_at_ref(<ItemT>)(slice ItemT[], index u64, file Str = #file, line i32 = #line, column i32 = #column) ItemT* {
    assert(index < slice.count, "out of bounds", .file = file, .line = line, .column = column);
    return &buf_at(slice.buf, index)
}

extern("c") fn own_printf(format Str, args opaque...) i32
extern("c") fn own_fprintf(file File, format Str, args opaque...) i32

// TODO: remove keep_going parameter from std?
fn assert(condition u1, message Str = "", keep_going u1 = 0, file Str = #file, line i32 = #line, column i32 = #column) {
    if (!condition) {
        own_fprintf(
            {own_stderr()},
            "%.*s:%d:%d:assertion failure: %s\n",
            unsafe_cast<i32>file.count,
            file.buf,
            unsafe_cast<i32>line,
            unsafe_cast<i32>column,
            message
        )
        if (!keep_going) {
            abort()
        }
    }
}

fn bitwise_not(<NumT>)(num NumT) NumT {
    return unsafe_cast<NumT>(-1)^num
}

extern("c") fn own_stdout() opaque*
extern("c") fn own_stderr() opaque*
extern("c") fn own_stdin() opaque*

extern("c") fn abort()
