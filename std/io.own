type rt import = std.runtime
type libc import = std.libc
type coll import = std.collections
type util import = std.util

extern("c") fn own_printf(format Str, args opaque...) i32
extern("c") fn own_fprintf(file File, format Str, args opaque...) i32
extern("c") fn own_stdout() opaque*
extern("c") fn own_stderr() opaque*
extern("c") fn own_stdin() opaque*
extern("c") fn own_argv() Str[]

type printf def = libc.printf
type puts def = libc.puts
type fopen def = libc.fopen
type fputc def = libc.fputc

type File struct {
    file opaque*
}

fn stdout() File => return {own_stdout()}
fn stderr() File => return {own_stderr()}
fn stdin() File => return {own_stdin()}

fn argv() Str[] {
    return own_argv()
}

fn fgetc(file File) util.Optional(<u8>) {
    let ch i32 = libc.fgetc(file.file)
    if ch == libc.EOF => return .none
    return .some(unsafe_cast<u8>ch)
}

fn getline(file File, delim u8 = '\n') util.Optional(<coll.Darr(<u8>)>) {
    let new_str coll.Darr(<u8>) = coll.darr_new(<u8>)()
    for 1 {
        if let .some(ch) = fgetc(file) {
            coll.darr_append(&new_str, ch)
            if ch == delim => return .some(new_str)
        } else {
            coll.darr_free(&new_str)
            return .none
        }
    }
    return .none
}

// TODO: return Result instead of Optional to specify the reason for open_file failing
fn open_file(file_path Str, options Str) util.Optional(<File>) {
    let cstr_path u8* = util.str_to_cstr(file_path)
    defer util.cstr_free(cstr_path)
    let cstr_opts u8* = util.str_to_cstr(options)
    defer util.cstr_free(cstr_opts)
    
    let ptr opaque* = libc.fopen(cstr_path, cstr_opts)
    if ptr == util.null(<opaque>)() => return .none
    return .some({ptr})
}

fn close_file(file File) util.Optional(<void>) {
    util.assert(file.file != util.null(<opaque>)(), "TODO")
    
    if 0 == libc.fclose(file.file) => return .none
    return .some
}

fn print_str_internal__(str coll.Str) {
    own_printf("%.*s", str.count, str.buf)
}

fn print_str(str coll.Str, end coll.Str = "\n") {
    print_str_internal__(str)
    print_str_internal__(end)
}

fn print_float(<NumT>)(num NumT, end coll.Str = "\n") {
    let cond u1 = num < 0.1 // this condition is to give errors for using non float type (for now)
    own_printf("%f", num)
    print_str_internal__(end)
}

fn print_int(<NumT>)(num NumT, end coll.Str = "\n", file coll.Str = #file, line i32 = #line, column i32 = #column) {
    let cond u1 = num < 1 // this condition is to give errors for using non int type (for now)
    util.assert(sizeof(num) <= 8, "bit widths larger than 8 not implemented", .file = file, .line = line, .column = column)
    own_printf("%lld", unsafe_cast<i64>num)
    print_str_internal__(end)
}

type Print_buf_fn def = fn(BufT, u8)void
type PrintFormatArg def = rt.PrintFormatArg
type PrintFormat def = rt.PrintFormat

fn print_i32(<BufT>)(print_buf BufT, print_buf_fn fn(BufT, u8)void, item opaque*) {
    let actual_item i32 = *unsafe_cast<i32*>item

    let buf u8[12] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    if actual_item < 0 {
        print_buf_fn(print_buf, '-')
    }

    let buf_idx usize = 11
    for actual_item > 0 {
        buf[buf_idx] = unsafe_cast<u8>(actual_item%10) + '0'
        assert(buf[buf_idx] > 0)

        actual_item /= 10
        buf_idx -= 1
    }

    buf_idx += 1

    for idx usize in buf_idx..12 {
        print_buf_fn(print_buf, buf[idx])
    }
}

fn print_buf_file(file File, ch u8) => fputc(ch, file.file)

fn print_internal(<BufT>)(format PrintFormat(<BufT>), print_buf_fn fn(BufT, u8)void, print_buf BufT) {
    let arg_idx usize = 0
    let skip_one u1 = 0
    
    for format_idx usize in 0..format.format.count {
        if skip_one {
            skip_one = 0
            continue
        }

        if (format.format[format_idx] == '%') {
            if (format.format[format_idx + 1] == '%') {
                print_buf_fn(print_buf, format.format[format_idx])
                skip_one = 1
            } else {
                // TODO: remove PrintFormatArg(<BufT>) when possible
                let curr PrintFormatArg(<BufT>) = format.args[arg_idx]
                curr.print_item_fn(print_buf, print_buf_fn, curr.item)
                arg_idx += 1
                skip_one = 1
            }
        } else {
            print_buf_fn(print_buf, format.format[format_idx])
        }
    }

    assert(arg_idx == format.args.count)
}

