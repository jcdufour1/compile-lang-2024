rt :: import = std.runtime
libc :: import = std.libc
coll :: import = std.collections
util :: import = std.util

own_argv :: extern("c") fn() Str[]

own_stdout :: def = rt.own_stdout
own_stderr :: def = rt.own_stderr
own_stdin :: def = rt.own_stdin

own_printf :: def = rt.own_printf
own_fprintf :: def = rt.own_fprintf

printf :: def = libc.printf
puts :: def = libc.puts
fopen :: def = libc.fopen
fputc :: def = libc.fputc

File :: def = rt.File

stdout :: fn() File => return {own_stdout()}
stderr :: fn() File => return {own_stderr()}
stdin :: fn() File => return {own_stdin()}

argv :: fn() Str[] {
    return own_argv()
}

fgetc :: fn(file File) u8? {
    ch i32 := libc.fgetc(file.file)
    if ch == libc.EOF => return .none
    return .some(unsafe_cast<u8>ch)
}

getline :: fn(file File, delim u8 = '\n') coll.Darr(<u8>)? {
    new_str coll.Darr(<u8>) := coll.darr_new(<u8>)()
    for 1 {
        if let .some(ch) = fgetc(file) {
            coll.darr_append(&new_str, ch)
            if ch == delim => return .some(new_str)
        } else {
            coll.darr_free(&new_str)
            return .none
        }
    }
    return .none
}

// TODO: return Result instead of Optional to specify the reason for open_file failing
open_file :: fn(file_path Str, options Str) File? {
    cstr_path u8* := util.str_to_cstr(file_path)
    defer util.cstr_free(cstr_path)
    cstr_opts u8* := util.str_to_cstr(options)
    defer util.cstr_free(cstr_opts)
    
    ptr opaque* := libc.fopen(cstr_path, cstr_opts)
    if ptr == util.null(<opaque>)() => return .none
    return .some({ptr})
}

close_file :: fn(file File) void? {
    util.assert(file.file != util.null(<opaque>)(), "TODO")
    
    if 0 == libc.fclose(file.file) => return .none
    return .some
}

print_str_internal__ :: fn(str coll.Str) {
    own_printf("%.*s", str.count, str.buf)
}

print_str :: fn(str coll.Str, end coll.Str = "\n") {
    print_str_internal__(str)
    print_str_internal__(end)
}

print_float :: fn(<NumT>)(num NumT, end coll.Str = "\n") {
    cond u1 := num < 0.1 // this condition is to give errors for using non float type (for now)
    own_printf("%f", num)
    print_str_internal__(end)
}

print_int :: fn(<NumT>)(num NumT, end coll.Str = "\n", file coll.Str = #file, line i32 = #line, column i32 = #column) {
    cond u1 := num < 1 // this condition is to give errors for using non int type (for now)
    util.assert(sizeof(num) <= 8, "bit widths larger than 8 not implemented", .file = file, .line = line, .column = column)
    own_printf("%lld", unsafe_cast<i64>num)
    print_str_internal__(end)
}

Print_buf_ :: def = fn(BufT, u8)void

print_i32 :: fn(<BufT>)(print_buf BufT, print_buf_fn fn(BufT, u8)void, item opaque*) {
    actual_item i32 := *unsafe_cast<i32*>item

    // TODO: use util.zero
    buf u8[12] := [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    if actual_item < 0 {
        print_buf_fn(print_buf, '-')
    }

    buf_idx usize := 11
    for actual_item > 0 {
        buf[buf_idx] = unsafe_cast<u8>(actual_item%10) + '0'
        assert(buf[buf_idx] > 0)

        actual_item /= 10
        buf_idx -= 1
    }

    buf_idx += 1

    for idx usize in buf_idx..12 {
        print_buf_fn(print_buf, buf[idx])
    }
}

print_buf_file :: fn(file File, ch u8) => fputc(ch, file.file)

print_internal :: fn(<BufT>)(format PrintFormat(<BufT>), print_buf_fn fn(BufT, u8)void, print_buf BufT) {
    arg_idx usize := 0
    skip_one u1 := 0
    
    for format_idx usize in 0..format.format.count {
        if skip_one {
            skip_one = 0
            continue
        }

        if (format.format[format_idx] == '%') {
            if (format.format[format_idx + 1] == '%') {
                print_buf_fn(print_buf, format.format[format_idx])
                skip_one = 1
            } else {
                // TODO: remove PrintFormatArg(<BufT>) when possible
                curr PrintFormatArg(<BufT>) := format.args[arg_idx]
                curr.print_item_fn(print_buf, print_buf_fn, curr.item)
                arg_idx += 1
                skip_one = 1
            }
        } else {
            print_buf_fn(print_buf, format.format[format_idx])
        }
    }

    assert(arg_idx == format.args.count)
}

PrintFormatArg :: struct(<BufT>) {
    item opaque*
    print_item_fn fn(BufT, fn(BufT, u8)void, opaque*)void
}

PrintFormat :: struct(<BufT>) {
    format Str
    args PrintFormatArg(<BufT>)[]
}

