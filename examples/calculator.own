type io import = std.io
type coll import = std.collections
type c import = std.libc
type math import = std.math
type util import = std.util

fn is_whitespace(ch u8) u1 {
    return ch != '-' && 0 != c.isspace(unsafe_cast<i32>ch)
}

fn check_stack(amt_consumed u64, nums_len u64, min_nums_count u64) void? {
    if nums_len < min_nums_count {
        for idx u64 in 0..amt_consumed => io.print_str(" ", "")
        io.print_str("^");
        io.print_str("error: this operation requires at least ", "");
        io.print_int(min_nums_count, "");
        io.print_str(" numbers to be on the stack, but ", "");
        io.print_int(nums_len, "");
        io.print_str(" were found");
        return .none;
    }

    return .some;
}

fn calculate(line Str) {
    let old_line Str = line

    let nums = coll.darr_new(<i64>)()
    defer coll.darr_free(&nums)

    for line.count > 0 {
        assert(!is_whitespace('-'))

        let amt_consumed = old_line.count - line.count

        if let .some(ch) = coll.slice_consume(&line, '\n') {
            assert(line.count == 0)
            break
        }

        if let .some(ch) = coll.slice_try_get(&line, is_whitespace) => continue

        if let .some(ch) = coll.slice_consume(&line, '+') => {
            check_stack(amt_consumed, nums.count, 2)?
            let result = coll.darr_pop(&nums) + coll.darr_pop(&nums)
            coll.darr_append(&nums, result)
            continue
        }

        if let .some(ch) = coll.slice_consume(&line, '-') => {
            check_stack(amt_consumed, nums.count, 2)?
            let result = coll.darr_pop(&nums) - coll.darr_pop(&nums)
            coll.darr_append(&nums, result)
            continue
        }

        if let .some(ch) = coll.slice_consume(&line, '/') => {
            check_stack(amt_consumed, nums.count, 2)?
            let result = coll.darr_pop(&nums)/coll.darr_pop(&nums)
            coll.darr_append(&nums, result)
            continue
        }

        if let .some(ch) = coll.slice_consume(&line, '*') => {
            check_stack(amt_consumed, nums.count, 2)?
            let result = coll.darr_pop(&nums)*coll.darr_pop(&nums)
            coll.darr_append(&nums, result)
            continue
        }

        if let .some(ch) = coll.slice_consume(&line, '%') => {
            check_stack(amt_consumed, nums.count, 2)?
            let result = coll.darr_pop(&nums)%coll.darr_pop(&nums)
            coll.darr_append(&nums, result)
            continue
        }

        if let .some(ch) = coll.slice_consume(&line, '^') => {
            check_stack(amt_consumed, nums.count, 2)?
            let result = math.pow(coll.darr_pop(&nums), coll.darr_pop(&nums))
            coll.darr_append(&nums, result)
            continue
        }

        if let .some(ch) = coll.slice_consume(&line, 'e') => {
            coll.darr_append(&nums, math.e(<i64>)())
            continue
        }

        if coll.slice_starts_with(line, "pi") => {
            line = coll.slice_range(line, 2, line.count - 2)
            coll.darr_append(&nums, math.pi(<i64>)())
            continue
        }

        if coll.slice_starts_with(line, "sqrt") {
            check_stack(amt_consumed, nums.count, 1)?
            line = coll.slice_range(line, 4, line.count - 4)
            let result = math.sqrt(coll.darr_pop(&nums))
            coll.darr_append(&nums, result)
            continue
        }

        if coll.slice_starts_with(line, "log") {
            check_stack(amt_consumed, nums.count, 1)?
            line = coll.slice_range(line, 3, line.count - 3)
            let result = math.log(coll.darr_pop(&nums))
            coll.darr_append(&nums, result)
            continue
        }

        if coll.slice_starts_with(line, "abs") {
            check_stack(amt_consumed, nums.count, 1)?
            line = coll.slice_range(line, 3, line.count - 3)
            coll.darr_append(&nums, math.abs(coll.darr_pop(&nums)))
            continue
        }

        if let .some(num) = coll.str_consume_int(<i64>)(&line) {
            coll.darr_append(&nums, num)
            continue
        }

        io.print_str("error: unknown operation \"", "")
        io.print_str(line, "")
        io.print_str("\"")
        return
    }

    if nums.count == 1 {
        io.print_int(coll.darr_first(nums))
    } else {
        io.print_str("error: there are ", "")
        io.print_int(nums.count, "")
        io.print_str(" numbers in the stack after all operations, but 1 is expected")
    }
}

fn main() i32 {
    for 1 {
        if let .some(line) = io.getline(io.stdin()) {
            calculate(coll.darr_slice(line))
            coll.darr_free(&line)
        } else {
            return 0
        }
    }

    assert(0, "unreachable");
    return 0
}
