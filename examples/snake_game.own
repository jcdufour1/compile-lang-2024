
type io import = std.io
type rl import = std.raylib
type rand import = std.random
type libc import = std.libc
type util import = std.util
type coll import = std.collections

type Pos struct {
    x i32
    y i32
}

type Dir enum {
    up
    down
    left
    right
}

type Snake struct {
    nodes coll.Arr(<Pos>)
    dir Dir
}

fn snake_first(snake Snake) Pos {
    return coll.arr_first(snake.nodes)
}

fn snake_new(init_pos Pos, init_dir Dir, squares: Pos) Snake {
    let max u64 = unsafe_cast<u64>(squares.x*squares.y)
    let arr coll.Arr(<Pos>) = coll.arr_new(max, Pos);
    util.assert(arr.buf != unsafe_cast<Pos*>0, "out of memory")
    coll.arr_append(&arr, init_pos)
    return {arr, init_dir}
}

fn mod(a i32, b i32) i32 {
    return (a%b + b)%b;
}

    // TODO: test case for this
    //io.printf("pos at idx 1 = {%d, %d}\n", snake.nodes.buf[1].x, snake.nodes.buf[1].y)
fn move_snake(snake Snake*, squares Pos, do_grow u1) u1 {
    let new_pos Pos = snake_first(*snake)
    util.assert(snake.nodes.count > 0)
    let last_pos Pos = snake.nodes.buf[snake.nodes.count - 1]
    switch snake.dir {
        case .down: new_pos.y += 1
        case .up: new_pos.y -= 1
        case .right: new_pos.x += 1
        case .left: new_pos.x -= 1
    }
    new_pos.x = mod(new_pos.x, squares.x)
    new_pos.y = mod(new_pos.y, squares.y)

    // detect snake collisions with itself
    for idx u64 in 0..snake.nodes.count {
        if pos_is_equal(snake.nodes.buf[idx], new_pos) {
            return 0
        }
    }
    
    let pos_at_1 Pos = snake.nodes.buf[1]
    // TODO: test case for this
    //io.printf("pos at idx 1 = {%d, %d}\n", snake.nodes.buf[1].x, snake.nodes.buf[1].y)
    for idx_ u64 in 1..(snake.nodes.count) {
        let idx u64 = snake.nodes.count - idx_
        util.assert(idx < snake.nodes.count, "out of bounds")
        snake.nodes.buf[idx] = snake.nodes.buf[idx - 1]
    }
    snake.nodes.buf[0] = new_pos

    if do_grow {
        coll.arr_append(&snake.nodes, last_pos)
    }

    return 1
}

fn pos_is_equal(lhs Pos, rhs Pos) u1 {
    return lhs.x == rhs.x && lhs.y == rhs.y
}

type State struct {

}

fn main() i32 {
    let BORDER_WIDTH i32 = 5
    let SQUARES Pos = {20, 10};
    let SQUARE_WIDTH i32 = 30;

    let CANVAS Pos = {SQUARES.x*SQUARE_WIDTH + 2*BORDER_WIDTH, SQUARES.y*SQUARE_WIDTH + 2*BORDER_WIDTH}

    let FRAME_RATE i32 = 7
    let LOOP_RATE i32 = 200;

    let snake Snake = snake_new({7, 9}, .right, SQUARES)
    util.assert(0 < SQUARES.x && 0 < SQUARES.y, "invalid snake cordinates")

    // TODO: call srand or similar
    let apple Pos = {rand.int_range(0, SQUARES.x), rand.int_range(0, SQUARES.y)}

    rl.InitWindow(CANVAS.x, CANVAS.y, "Snake Game")
    defer rl.CloseWindow()

    let loop_count i32 = 0
    let do_grow_snake u1 = 0
    rl.SetTargetFPS(LOOP_RATE)

    let game_is_over u1 = 0
    for !rl.WindowShouldClose() {
        rl.BeginDrawing()
        rl.ClearBackground(rl.BLACK());

        if game_is_over {
            rl.DrawText("game over: collision", CANVAS.x/3, CANVAS.y/2, 30, rl.WHITE())
            rl.DrawText("press enter to restart", CANVAS.x/3, CANVAS.y/2 + 50, 22, rl.WHITE())
            rl.EndDrawing()

            if rl.IsKeyPressed(rl.KEY_ENTER()) {
                game_is_over = 0
                coll.arr_free(&snake.nodes);
                snake = snake_new({7, 9}, .right, SQUARES)
            }
        } else {
            rl.DrawRectangleLinesEx({0.0, 0.0, unsafe_cast<f32>CANVAS.x, unsafe_cast<f32>CANVAS.y}, unsafe_cast<f32>BORDER_WIDTH, rl.WHITE())

            for idx u64 in 0..snake.nodes.count {
                let curr Pos = snake.nodes.buf[idx]
                rl.DrawRectangle(BORDER_WIDTH + SQUARE_WIDTH*curr.x, BORDER_WIDTH + SQUARE_WIDTH*curr.y, SQUARE_WIDTH, SQUARE_WIDTH, rl.YELLOW())
            }
            rl.DrawRectangle(BORDER_WIDTH + SQUARE_WIDTH*apple.x, BORDER_WIDTH + SQUARE_WIDTH*apple.y, SQUARE_WIDTH, SQUARE_WIDTH, rl.RED())

            rl.EndDrawing()

            if rl.IsKeyPressed(rl.KEY_W()) || rl.IsKeyPressed(rl.KEY_UP()) {
                snake.dir = .up
            } else if rl.IsKeyPressed(rl.KEY_S()) || rl.IsKeyPressed(rl.KEY_DOWN()) {
                snake.dir = .down
            } else if rl.IsKeyPressed(rl.KEY_A()) || rl.IsKeyPressed(rl.KEY_LEFT()) {
                snake.dir = .left
            } else if rl.IsKeyPressed(rl.KEY_D()) || rl.IsKeyPressed(rl.KEY_RIGHT()) {
                snake.dir = .right
            }

            // check for apple collision
            for snake_ u64 in 0..snake.nodes.count {
                let curr Pos = snake.nodes.buf[snake_]
                if pos_is_equal(curr, apple) {
                    do_grow_snake = 1
                    apple = {rand.int_range(0, SQUARES.x), rand.int_range(0, SQUARES.y)}
                }
            }

            if (loop_count >= LOOP_RATE/FRAME_RATE) {
                if !move_snake(&snake, SQUARES, do_grow_snake) {
                    game_is_over = 1
                }
                do_grow_snake = 0
                io.printf(
                    "snake.nodes.count = %zu\n",
                    snake.nodes.count)
                loop_count -= LOOP_RATE/FRAME_RATE
            }

            loop_count += 1
        }
    }

    return 0
}
