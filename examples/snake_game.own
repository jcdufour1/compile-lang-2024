
io :: import = std.io
rl :: import = std.raylib
rand :: import = std.random
libc :: import = std.libc
util :: import = std.util
coll :: import = std.collections

Pos :: struct {
    x i32
    y i32
}

Dir :: enum {
    up
    down
    left
    right
}

Snake :: struct {
    nodes coll.Darr(<Pos>)
    dir Dir
}

State :: enum {
    normal
    over
    paused
}

snake_first :: fn(snake Snake) Pos {
    return coll.darr_first(snake.nodes)
}

snake_new :: fn(init_pos Pos, init_dir Dir, squares: Pos) Snake {
    darr := coll.darr_new(<Pos>)([init_pos]);
    return {darr, init_dir}
}

mod :: fn(a i32, b i32) i32 {
    return (a%b + b)%b;
}

// TODO: test case for this
//io.printf("pos at idx 1 = {%d, %d}\n", snake.nodes.buf[1].x, snake.nodes.buf[1].y)
move_snake :: fn(snake Snake*, squares Pos, do_grow u1) u1 {
    new_pos := snake_first(*snake)
    assert(snake.nodes.count > 0)
    last_pos := coll.darr_at(snake.nodes, snake.nodes.count - 1)
    switch snake.dir {
        case .down: new_pos.y += 1
        case .up: new_pos.y -= 1
        case .right: new_pos.x += 1
        case .left: new_pos.x -= 1
    }
    new_pos.x = mod(new_pos.x, squares.x)
    new_pos.y = mod(new_pos.y, squares.y)

    // detect snake collisions with itself
    for idx in 0..snake.nodes.count {
        if pos_is_equal(coll.darr_at(snake.nodes, idx), new_pos) {
            return 0
        }
    }
    
    pos_at_1 := coll.darr_at(snake.nodes, 0)
    for idx_ in 1..snake.nodes.count {
        idx := snake.nodes.count - idx_
        assert(idx < snake.nodes.count, "out of bounds")
        *coll.darr_at_ref(snake.nodes, idx) = coll.darr_at(snake.nodes, idx - 1)
    }
    *coll.darr_at_ref(snake.nodes, 0) = new_pos

    if do_grow {
        coll.darr_append(&snake.nodes, last_pos)
    }

    return 1
}

pos_is_equal :: fn(lhs Pos, rhs Pos) u1 {
    return lhs.x == rhs.x && lhs.y == rhs.y
}

rand_pos :: fn(squares Pos) Pos {
    return {rand.int_range(0, squares.x), rand.int_range(0, squares.y)}
}

draw_items :: fn(canvas Pos, border_width i32, square_width i32, snake Snake, apples coll.Darr(<Pos>)) {
    rl.DrawRectangleLinesEx({0.0, 0.0, unsafe_cast<f32>canvas.x, unsafe_cast<f32>canvas.y}, unsafe_cast<f32>border_width, rl.WHITE())

    for idx in 0..snake.nodes.count {
        curr := coll.darr_at(snake.nodes, idx)
        rl.DrawRectangle(border_width + square_width*curr.x, border_width + square_width*curr.y, square_width, square_width, rl.YELLOW())
    }
    for idx in 0..apples.count {
        curr := coll.darr_at(apples, idx)
        rl.DrawRectangle(border_width + square_width*curr.x, border_width + square_width*curr.y, square_width, square_width, rl.RED())
    }
}

main :: fn() i32 {
    COUNT_APPLES := 3
    BORDER_WIDTH := 5
    SQUARES Pos := {20, 10};
    SQUARE_WIDTH := 30;

    CANVAS Pos := {SQUARES.x*SQUARE_WIDTH + 2*BORDER_WIDTH, SQUARES.y*SQUARE_WIDTH + 2*BORDER_WIDTH}

    FRAME_RATE := 7
    LOOP_RATE := 200;

    rand.srand()

    snake := snake_new(rand_pos(SQUARES), .right, SQUARES)
    assert(0 < SQUARES.x && 0 < SQUARES.y, "invalid snake cordinates")

    apples := coll.darr_new(<Pos>)()
    for idx in 0..COUNT_APPLES {
        coll.darr_append(&apples, rand_pos(SQUARES))
    }

    rl.InitWindow(CANVAS.x, CANVAS.y, "Snake Game")
    defer rl.CloseWindow()

    loop_count := 0
    do_grow_snake u1 := 0
    rl.SetTargetFPS(LOOP_RATE)

    game_state State := .normal
    for !rl.WindowShouldClose() {
        rl.BeginDrawing()
        rl.ClearBackground(rl.BLACK());

        switch game_state {
            case .paused:{
                draw_items(CANVAS, BORDER_WIDTH, SQUARE_WIDTH, snake, apples)
                rl.EndDrawing()

                if rl.IsKeyPressed(rl.KEY_SPACE()) {
                    game_state = .normal
                }
            }
            case .over: {
                rl.DrawText("game over", CANVAS.x/3, CANVAS.y/2 - 50, 30, rl.WHITE())
                rl.DrawText(
                    rl.TextFormat("snake length: %zu", snake.nodes.count),
                    CANVAS.x/3,
                    CANVAS.y/2,
                    30,
                    rl.WHITE())
                rl.DrawText("press enter to restart", CANVAS.x/3, CANVAS.y/2 + 50, 22, rl.WHITE())
                rl.EndDrawing()

                if rl.IsKeyPressed(rl.KEY_ENTER()) {
                    game_state = .normal
                    coll.darr_free(&snake.nodes);
                    snake = snake_new(rand_pos(SQUARES), .right, SQUARES)
                }
            }
            case .normal: {
                draw_items(CANVAS, BORDER_WIDTH, SQUARE_WIDTH, snake, apples)
                rl.EndDrawing()

                if rl.IsKeyPressed(rl.KEY_W()) || rl.IsKeyPressed(rl.KEY_UP()) {
                    snake.dir = .up
                } else if rl.IsKeyPressed(rl.KEY_S()) || rl.IsKeyPressed(rl.KEY_DOWN()) {
                    snake.dir = .down
                } else if rl.IsKeyPressed(rl.KEY_A()) || rl.IsKeyPressed(rl.KEY_LEFT()) {
                    snake.dir = .left
                } else if rl.IsKeyPressed(rl.KEY_D()) || rl.IsKeyPressed(rl.KEY_RIGHT()) {
                    snake.dir = .right
                } else if rl.IsKeyPressed(rl.KEY_SPACE()) {
                    game_state = .paused
                }

                // check for apple collision
                for snake_ in 0..snake.nodes.count {
                    curr := coll.darr_at(snake.nodes, snake_)
                    for apple in 0..apples.count {
                        if pos_is_equal(curr, coll.darr_at(apples, apple)) {
                            do_grow_snake = 1
                            *coll.darr_at_ref(apples, apple) = rand_pos(SQUARES)
                        }
                    }
                }

                if (loop_count >= LOOP_RATE/FRAME_RATE) {
                    if !move_snake(&snake, SQUARES, do_grow_snake) {
                        game_state = .over
                    }
                    do_grow_snake = 0
                    loop_count -= LOOP_RATE/FRAME_RATE
                }

                loop_count += 1
            }
        }
    }

    return 0
}
