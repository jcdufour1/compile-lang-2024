
type io import = std.io
type rl import = std.raylib
type rand import = std.random
type libc import = std.libc
type util import = std.util
type coll import = std.collections

type Pos struct {
    x i32
    y i32
}

type Dir enum {
    up
    down
    left
    right
}

type Snake struct {
    nodes coll.Arr(<Pos>)
    dir Dir
}

type State enum {
    normal
    over
    paused
}

fn snake_first(snake Snake) Pos {
    return coll.arr_first(snake.nodes)
}

fn snake_new(init_pos Pos, init_dir Dir, squares: Pos) Snake {
    let max u64 = unsafe_cast<u64>(squares.x*squares.y)
    let arr coll.Arr(<Pos>) = coll.arr_new(max, Pos, [init_pos]);
    return {arr, init_dir}
}

fn mod(a i32, b i32) i32 {
    return (a%b + b)%b;
}

    // TODO: test case for this
    //io.printf("pos at idx 1 = {%d, %d}\n", snake.nodes.buf[1].x, snake.nodes.buf[1].y)
fn move_snake(snake Snake*, squares Pos, do_grow u1) u1 {
    let new_pos Pos = snake_first(*snake)
    util.assert(snake.nodes.count > 0)
    let last_pos Pos = snake.nodes.buf[snake.nodes.count - 1]
    switch snake.dir {
        case .down: new_pos.y += 1
        case .up: new_pos.y -= 1
        case .right: new_pos.x += 1
        case .left: new_pos.x -= 1
    }
    new_pos.x = mod(new_pos.x, squares.x)
    new_pos.y = mod(new_pos.y, squares.y)

    // detect snake collisions with itself
    for idx u64 in 0..snake.nodes.count {
        if pos_is_equal(snake.nodes.buf[idx], new_pos) {
            return 0
        }
    }
    
    let pos_at_1 Pos = snake.nodes.buf[1]
    for idx_ u64 in 1..(snake.nodes.count) {
        let idx u64 = snake.nodes.count - idx_
        util.assert(idx < snake.nodes.count, "out of bounds")
        snake.nodes.buf[idx] = snake.nodes.buf[idx - 1]
    }
    snake.nodes.buf[0] = new_pos

    if do_grow {
        coll.arr_append(&snake.nodes, last_pos)
    }

    return 1
}

fn pos_is_equal(lhs Pos, rhs Pos) u1 {
    return lhs.x == rhs.x && lhs.y == rhs.y
}

fn rand_pos(squares Pos) Pos {
    return {rand.int_range(0, squares.x), rand.int_range(0, squares.y)}
}

fn draw_items(canvas Pos, border_width i32, square_width i32, snake Snake, apples coll.Arr(<Pos>)) {
    rl.DrawRectangleLinesEx({0.0, 0.0, unsafe_cast<f32>canvas.x, unsafe_cast<f32>canvas.y}, unsafe_cast<f32>border_width, rl.WHITE())

    for idx u64 in 0..snake.nodes.count {
        let curr Pos = snake.nodes.buf[idx]
        rl.DrawRectangle(border_width + square_width*curr.x, border_width + square_width*curr.y, square_width, square_width, rl.YELLOW())
    }
    for idx u64 in 0..apples.count {
        let curr Pos = coll.arr_at(apples, idx)
        rl.DrawRectangle(border_width + square_width*curr.x, border_width + square_width*curr.y, square_width, square_width, rl.RED())
    }
}

fn main() i32 {
    let BORDER_WIDTH i32 = 5
    let SQUARES Pos = {20, 10};
    let SQUARE_WIDTH i32 = 30;
    let COUNT_APPLES u64 = 3;

    let CANVAS Pos = {SQUARES.x*SQUARE_WIDTH + 2*BORDER_WIDTH, SQUARES.y*SQUARE_WIDTH + 2*BORDER_WIDTH}

    let FRAME_RATE i32 = 7
    let LOOP_RATE i32 = 200;

    rand.srand()

    let snake Snake = snake_new(rand_pos(SQUARES), .right, SQUARES)
    util.assert(0 < SQUARES.x && 0 < SQUARES.y, "invalid snake cordinates")

    let apples coll.Arr(<Pos>) = coll.arr_new(COUNT_APPLES, Pos)
    for idx u64 in 0..COUNT_APPLES {
        coll.arr_append(&apples, rand_pos(SQUARES))
    }

    rl.InitWindow(CANVAS.x, CANVAS.y, "Snake Game")
    defer rl.CloseWindow()

    let loop_count i32 = 0
    let do_grow_snake u1 = 0
    rl.SetTargetFPS(LOOP_RATE)

    let game_state State = .normal
    for !rl.WindowShouldClose() {
        rl.BeginDrawing()
        rl.ClearBackground(rl.BLACK());

        switch game_state {
            case .paused:{
                draw_items(CANVAS, BORDER_WIDTH, SQUARE_WIDTH, snake, apples)
                rl.EndDrawing()

                if rl.IsKeyPressed(rl.KEY_SPACE()) {
                    game_state = .normal
                }
            }
            case .over: {
                rl.DrawText("game over", CANVAS.x/3, CANVAS.y/2 - 50, 30, rl.WHITE())
                rl.DrawText(
                    rl.TextFormat("snake length: %zu", snake.nodes.count),
                    CANVAS.x/3,
                    CANVAS.y/2,
                    30,
                    rl.WHITE())
                rl.DrawText("press enter to restart", CANVAS.x/3, CANVAS.y/2 + 50, 22, rl.WHITE())
                rl.EndDrawing()

                if rl.IsKeyPressed(rl.KEY_ENTER()) {
                    game_state = .normal
                    coll.arr_free(&snake.nodes);
                    snake = snake_new(rand_pos(SQUARES), .right, SQUARES)
                }
            }
            case .normal: {
                draw_items(CANVAS, BORDER_WIDTH, SQUARE_WIDTH, snake, apples)
                rl.EndDrawing()

                if rl.IsKeyPressed(rl.KEY_W()) || rl.IsKeyPressed(rl.KEY_UP()) {
                    snake.dir = .up
                } else if rl.IsKeyPressed(rl.KEY_S()) || rl.IsKeyPressed(rl.KEY_DOWN()) {
                    snake.dir = .down
                } else if rl.IsKeyPressed(rl.KEY_A()) || rl.IsKeyPressed(rl.KEY_LEFT()) {
                    snake.dir = .left
                } else if rl.IsKeyPressed(rl.KEY_D()) || rl.IsKeyPressed(rl.KEY_RIGHT()) {
                    snake.dir = .right
                } else if rl.IsKeyPressed(rl.KEY_SPACE()) {
                    game_state = .paused
                }

                // check for apple collision
                for snake_ u64 in 0..snake.nodes.count {
                    let curr Pos = snake.nodes.buf[snake_]
                    for apple u64 in 0..apples.count {
                        if pos_is_equal(curr, coll.arr_at(apples, apple)) {
                            do_grow_snake = 1
                            *coll.arr_at_ref(apples, apple) = rand_pos(SQUARES)
                        }
                    }
                }

                if (loop_count >= LOOP_RATE/FRAME_RATE) {
                    if !move_snake(&snake, SQUARES, do_grow_snake) {
                        game_state = .over
                    }
                    do_grow_snake = 0
                    loop_count -= LOOP_RATE/FRAME_RATE
                }

                loop_count += 1
            }
        }
    }

    return 0
}
